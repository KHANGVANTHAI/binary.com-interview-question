---
title: "<img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/757b27e1e93132368b0898152078be4961b05a28/www/binary-logo-resize.jpg' width='240'>"
subtitle: "[<span style='color:blue'>binary.com</span>](https://github.com/englianhu/binary.com-interview-question) Interview Question I"
author: "[<span style='color:blue'>®γσ, Lian Hu</span>](https://englianhu.github.io/) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/ENG.jpg' width='24'> <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/RYO.jpg?raw=true' width='24'>®"
date: "`r Sys.Date()`"
output:
  tufte::tufte_html:
    toc: yes
    toc_depth: 4
    self_contained: no
    number_sections: true
  tufte::tufte_book:
    citation_package: natbib
    latex_engine: xelatex
  tufte::tufte_handout:
    citation_package: natbib
    latex_engine: xelatex
link-citations: yes
---

```{r setup, include = FALSE}
suppressPackageStartupMessages(library('BBmisc'))
pkgs <- c('knitr', 'kableExtra', 'tint', 'devtools', 'lubridate', 'plyr', 'stringr', 'magrittr', 'dplyr', 'tidyr', 'tidyverse', 'tidyquant', 'turner', 'readr', 'quantmod', 'htmltools', 'highcharter', 'googleVis', 'formattable', 'ggfortify', 'DT', 'forecast', 'Mcomp', 'bsts', 'MCMCpack', 'PerformanceAnalytics', 'broom', 'microbenchmark', 'doParallel', 'Boruta', 'fBasics', 'fPortfolio', 'rugarch', 'parma', 'rmgarch')
 
suppressAll(lib(pkgs))
#'@ install.packages(pkgs, lib = 'C:/Program Files/R/R-3.4.0/library')

suppressAll(l_ply(c('last.R', 'Mn.R', 'has.Mn.R', 'simAutoArima.R', 'simStakesAutoArima.R', 'simETS.R', 'simStakesETS.R', 'plotChart2.R', 'armaSearch.R', 'simGarch.R', 'simStakesGarch.R'), function(pkg) source(paste0('./function/', pkg))))

## Directly install the developing packages.
#'@ require(devtools)
#'@ install_bitbucket("rugarch","alexiosg")
#'@ install_bitbucket("rmgarch","alexiosg")
#'@ install_bitbucket("racd","alexiosg")
#'@ install_bitbucket("twinkle","alexiosg")
#'@ install_bitbucket("spd","alexiosg")
#'@ install_bitbucket("parma","alexiosg")

## Set option to below if you want to plot an independent webpage with graph 
#'@ op <- options(gvis.plot.tag=NULL)
op <- options(gvis.plot.tag = 'chart')
options(gvis.plot.tag = 'chart', warn = -1)
#'@ options(rpubs.upload.method = 'internal')

## R: llply fully reproducible results in parallel
## https://stackoverflow.com/questions/34946177/r-llply-fully-reproducible-results-in-parallel
cl <- makeCluster(detectCores())
registerDoParallel(cl)

# Create a cluster object to be used for rugarcgh and rmgarch models.
cluster = makePSOCKcluster(15)

# invalidate cache when the package version changes
#'@ knitr::opts_chunk$set(tidy = FALSE, cache.extra = packageVersion('tint'))
rm(pkgs)
#'@ options(htmltools.dir.version = FALSE)
```

# 1. Introduction

  Below are the questionaire. Here I created this file to apply `MCMCpack` and `forecast` to compelete the questions prior to completed the `Ridge`, `ElasticNet` and `LASSO` regression (quite alot of models for comparison)^[We can use `cv.glmnet()` in `glmnet` package or `caret` package for cross validation models. You can refer to [<span style='color:blue'>Algorithmic Trading</span>](https://robotwealth.com/caterory/algorithmic-trading/page/4/) and [<span style='color:blue'>Successful Algorithmic Trading</span>](https://raw.githubusercontent.com/englianhu/binary.com-interview-question/fcad2844d7f10c486f3601af9932f49973548e4b/reference/Successful%20Algorithmic%20Trading.pdf) which applied cross-validation in focasting in financial market. You can buy the ebook with full Python coding of [<span style='color:blue'>Successful Algorithmic Trading</span>](https://www.quantstart.com/successful-algorithmic-trading-ebook) as well.].

<iframe width="560" height="315" src="https://www.youtube.com/embed/Aw77aMLj9uM" frameborder="0" allowfullscreen></iframe>

<center><iframe src="https://raw.githubusercontent.com/englianhu/binary.com-interview-question/ff20ee95aa60ef5cca3cf797066089103eb62acf/reference/quant-analyst-skills-test.pdf" width="600" height="900"></iframe></center>

# 2. Content

## 2.1 Question 1

### 2.1.1 Read Data

  I use 3 years data for the question as experiment, 1st year data is burn-in data for statistical modelling and prediction purpose while following 2 years data for forecasting and staking. There have 252 trading days within a year.

```{r read-data, echo = FALSE, eval = FALSE}
## ================== eval = FALSE =============================
## Do not execute...
## 
## Remove all objects include hidden objects.
rm(list = ls(all.names = TRUE))

## get currency dataset online.
getFX('USD/JPY', from = '2014-01-01', to = '2017-01-20') #oanda only provides 180 days data. getSymbols()
#'@ USDJPY <- readRDS('./data/USDJPY.rds')
USDJPY <- xts(USDJPY[, -1], order.by = USDJPY$Date)

## dateID
dateID <- index(mbase)
dateID0 <- ymd('2015-01-01')
dateID <- dateID[dateID > dateID0]
obs.data <- USDJPY[index(USDJPY) > dateID0]

## Now we try to use the daily mean value which is (Hi + Lo) / 2.
pred.data <- ldply(dateID, function(dt) {
  smp = USDJPY
  dtr = last(index(smp[index(smp) < dt]))
  smp = smp[paste0(dtr %m-% years(1), '/', dtr)]
  frd = as.numeric(difftime(dt, dtr), units = 'days')
  fit = ets(smp) #https://www.otexts.org/fpp/7/7
  data.frame(Date = dt, forecast(fit, h = frd)) %>% tbl_df
  }, .parallel = FALSE) %>% tbl_df

cmp.data <- xts(pred.data[, -1], order.by = pred.data$Date)
cmp.data <- cbind(cmp.data, obs.data)
rm(obs.data, pred.data)

# Test the models
lm(Point.Forecast~ USD.JPY, data = cmp.data)
MCMCregress(Point.Forecast~ USD.JPY, data = cmp.data)

plot(forecast(fit))
forecast(fit, h = 4)
```

```{r read-data2, warning = FALSE}
## get currency dataset online.
## http://stackoverflow.com/questions/24219694/get-symbols-quantmod-ohlc-currency-data
#'@ getFX('USD/JPY', from = '2014-01-01', to = '2017-01-20')

## getFX() doesn't shows Op, Hi, Lo, Cl price but only price. Therefore no idea to place bets.
#'@ USDJPY <- getSymbols('JPY=X', src = 'yahoo', from = '2014-01-01', 
#'@                      to = '2017-01-20', auto.assign = FALSE)
#'@ names(USDJPY) <- str_replace_all(names(USDJPY), 'JPY=X', 'USDJPY')
#'@ USDJPY <- xts(USDJPY[, -1], order.by = USDJPY$Date)

#'@ saveRDS(USDJPY, './data/USDJPY.rds')
USDJPY <- read_rds(path = './data/USDJPY.rds')
mbase <- USDJPY

## dateID
dateID <- index(mbase)
dateID0 <- ymd('2015-01-01')
dateID <- dateID[dateID > dateID0]
```

```{r data-summary}
dim(mbase)
summary(mbase) %>% kable(width = 'auto')
```

### 2.1.2 Statistical Modelling

#### 2.1.2.1 ARIMA vs ETS
  
  <span style='color:red'>**Remarks :** *Here I try to predict the sell/buy price and also settled price. However just noticed the question asking about prediction of the variance^[The profit is made based on the range of variance Hi-Lo price but not the accuracy of the highest, lowest or closing price.] based on mean price. I can also use the focasted highest and forecasted lowest price for variance prediction as well. However I will conduct another study and answer for the variance with Garch models.*</span>

  Below are some articles with regards exponential smoothing.
  
 - [<span style='color:blue'>Recent Advances in Robust Statistics: Theory and Applications</span>](https://books.google.com.my/books?id=ntR5DQAAQBAJ&pg=PA174&lpg=PA174&dq=exponential+smoothing+mcmc&source=bl&ots=QANf4o9oFh&sig=JWov-64qeFTcOScG2pYj9OVCl2k&hl=ja&sa=X&redir_esc=y#v=onepage&q=exponential%20smoothing%20mcmc&f=false)
 - [<span style='color:blue'>Error, trend, seasonality - ets and its forecast model friends</span>](http://ellisp.github.io/blog/2016/11/27/ets-friends)
 - [<span style='color:blue'>A study of outliers in the exponential smoothing approach to forecasting</span>](https://www.statindex.org/articles/258660)
 - [<span style='color:blue'>8.10 ARIMA vs ETS</span>](https://www.otexts.org/fpp/8/10)
 - [<span style='color:blue'>Introduction to ARIMA : nonseasonal models</span>](http://people.duke.edu/~rnau/411arim.htm#les)

  It is a common myth that ARIMA models are more general than exponential smoothing. While linear exponential smoothing models are all special cases of ARIMA models, the non-linear exponential smoothing models have no equivalent ARIMA counterparts. There are also many ARIMA models that have no exponential smoothing counterparts. In particular, every ETS model^[[<span style='color:blue'>**forecast::ets()**</span>](https://www.rdocumentation.org/packages/forecast/versions/7.3/topics/ets) : Usually a three-character string identifying method using the framework terminology of Hyndman et al. (2002) and Hyndman et al. (2008). The first letter denotes the error type ("A", "M" or "Z"); the second letter denotes the trend type ("N","A","M" or "Z"); and the third letter denotes the season type ("N","A","M" or "Z"). In all cases, "N"=none, "A"=additive, "M"=multiplicative and "Z"=automatically selected. So, for example, "ANN" is simple exponential smoothing with additive errors, "MAM" is multiplicative Holt-Winters' method with multiplicative errors, and so on.
It is also possible for the model to be of class "ets", and equal to the output from a previous call to ets. In this case, the same model is fitted to y without re-estimating any smoothing parameters. See also the use.initial.values argument.] is non-stationary, while ARIMA models can be stationary.

  The ETS models with seasonality or non-damped trend or both have two unit roots (i.e., they need two levels of differencing to make them stationary). All other ETS models have one unit root (they need one level of differencing to make them stationary).

  The following table gives some equivalence relationships for the two classes of models.

  | ETS model	          | ARIMA model	                          | Parameters                    |
  |:-------------------:|:-------------------------------------:|:-----------------------------:|
  | $ETS(A, N, N)$	    | $ARIMA(0, 1, 1)$	                    | $θ_{1} = α − 1$               |
  | $ETS(A, A, N)$	    | $ARIMA(0, 2, 2)$	                    | $θ_{1} = α + β − 2$           |
  |                     |                                       | $θ_{2} = 1 − α$               |
  | $ETS(A, A_{d}, N)$	| $ARIMA(1, 1, 2)$	                    | $ϕ_{1} = ϕ$                   |
  |                     |                                       | $θ_{1} = α + ϕβ − 1 −  ϕ$     |
  |                     |                                       | $θ_{2} = (1 − α)ϕ$            |
  | $ETS(A, N, A)$	    | $ARIMA(0, 0, m)(0, 1, 0)_{m}$	        |                               |
  | $ETS(A, A, A)$	    | $ARIMA(0, 1, m+1)(0, 1, 0)_{m}$	      |                               |
  | $ETS(A, A_{d}, A)$	| $ARIMA(1, 0, m+1)(0, 1, 0)_{m}$	      |                               |

  For the seasonal models, there are a large number of restrictions on the ARIMA parameters.

  Kindly refer to [<span style='color:blue'>*8.10 ARIMA vs ETS*</span>](https://www.otexts.org/fpp/8/10) for further details.

```{r build-AutoArima}
## Modelling Auto Arima focasting data.
#'@ fitAutoArima.op <- suppressAll(simAutoArima(USDJPY, .prCat = 'Op')) #will take a minute
#'@ saveRDS(fitAutoArima.op, './data/fitAutoArima.op.rds')

#'@ fitAutoArima.hi <- suppressAll(simAutoArima(USDJPY, .prCat = 'Hi')) #will take a minute
#'@ saveRDS(fitAutoArima.hi, './data/fitAutoArima.hi.rds')

#'@ fitAutoArima.mn <- suppressAll(simAutoArima(USDJPY, .prCat = 'Mn')) #will take a minute
#'@ saveRDS(fitAutoArima.mn, './data/fitAutoArima.mn.rds')

#'@ fitAutoArima.lo <- suppressAll(simAutoArima(USDJPY, .prCat = 'Lo')) #will take a minute
#'@ saveRDS(fitAutoArima.lo, './data/fitAutoArima.lo.rds')

#'@ fitAutoArima.cl <- suppressAll(simAutoArima(USDJPY, .prCat = 'Cl')) #will take a minute
#'@ saveRDS(fitAutoArima.cl, './data/fitAutoArima.cl.rds')

fitAutoArima.op <- readRDS('./data/fitAutoArima.op.rds')
fitAutoArima.hi <- readRDS('./data/fitAutoArima.hi.rds')
fitAutoArima.mn <- readRDS('./data/fitAutoArima.mn.rds')
fitAutoArima.lo <- readRDS('./data/fitAutoArima.lo.rds')
fitAutoArima.cl <- readRDS('./data/fitAutoArima.cl.rds')
```

```{r build-ETS}
## Modelling ETS focasting data.
#'@ fitETS.op <- suppressAll(simETS(USDJPY, .prCat = 'Op')) #will take a minute
#'@ saveRDS(fitETS.op, './data/fitETS.op.rds')

#'@ fitETS.hi <- suppressAll(simETS(USDJPY, .prCat = 'Hi')) #will take a minute
#'@ saveRDS(fitETS.hi, './data/fitETS.hi.rds')

#'@ fitETS.mn <- suppressAll(simETS(USDJPY, .prCat = 'Mn')) #will take a minute
#'@ saveRDS(fitETS.mn, './data/fitETS.mn.rds')

#'@ fitETS.lo <- suppressAll(simETS(USDJPY, .prCat = 'Lo')) #will take a minute
#'@ saveRDS(fitETS.lo, './data/fitETS.lo.rds')

#'@ fitETS.cl <- suppressAll(simETS(USDJPY, .prCat = 'Cl')) #will take a minute
#'@ saveRDS(fitETS.cl, './data/fitETS.cl.rds')

fitETS.op <- readRDS('./data/fitETS.op.rds')
fitETS.hi <- readRDS('./data/fitETS.hi.rds')
fitETS.mn <- readRDS('./data/fitETS.mn.rds')
fitETS.lo <- readRDS('./data/fitETS.lo.rds')
fitETS.cl <- readRDS('./data/fitETS.cl.rds')
```

**Application of MCMC**

  Need to refer to MCMC since I am using exponential smoothing models...

  - [<span style='color:blue'>Markov Chain Monte Carlo Method</span>](https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_introbayes_sect007.htm)
  - [<span style='color:blue'>Burn-In is Unnecessary</span>](http://users.stat.umn.edu/~geyer/mcmc/burn.html)
  - [<span style='color:blue'>**Nice R Code** *Punning code better since 2013*</span>](https://nicercode.github.io/guides/mcmc/)

```{r lm-ETS, warning = FALSE}
## Here I test the accuracy of forecasting of ets ZZZ model 1.

## Test the models
## opened price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitETS.op))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitETS.op))

## highest price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitETS.hi))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitETS.hi))

## mean price fit data (mean price of daily highest and lowest price)
summary(lm(Point.Forecast~ USDJPY.Close, data = fitETS.mn))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitETS.mn))

## lowest price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitETS.lo))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitETS.lo))

## closed price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitETS.cl))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitETS.cl))
```

**Mean Squared Error**

```{r combine-dataAutoArima}
fcdataAA <- do.call(cbind, list(USDJPY.FPOP.Open = fitAutoArima.op$Point.Forecast, 
                              USDJPY.FPHI.High = fitAutoArima.hi$Point.Forecast, 
                              USDJPY.FPMN.Mean = fitAutoArima.mn$Point.Forecast, 
                              USDJPY.FPLO.Low = fitAutoArima.lo$Point.Forecast, 
                              USDJPY.FPCL.Close = fitAutoArima.cl$Point.Forecast, 
                              USDJPY.Open = fitAutoArima.op$USDJPY.Open, 
                              USDJPY.High = fitAutoArima.op$USDJPY.High, 
                              USDJPY.Low = fitAutoArima.op$USDJPY.Low, 
                              USDJPY.Close = fitAutoArima.op$USDJPY.Close))
fcdataAA <- na.omit(fcdataAA)
names(fcdataAA) <- c('USDJPY.FPOP.Open', 'USDJPY.FPHI.High', 'USDJPY.FPMN.Mean', 
                   'USDJPY.FPLO.Low', 'USDJPY.FPCL.Close', 'USDJPY.Open', 
                   'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')

## Mean Squared Error : comparison of accuracy
paste('Open = ', mean((fcdataAA$USDJPY.FPOP.Open - fcdataAA$USDJPY.Open)^2))
paste('High = ', mean((fcdataAA$USDJPY.FPHI.High - fcdataAA$USDJPY.High)^2))
paste('Mean = ', mean((fcdataAA$USDJPY.FPMN.Mean - (fcdataAA$USDJPY.High + fcdataAA$USDJPY.Low)/2)^2))
paste('Low = ', mean((fcdataAA$USDJPY.FPLO.Low - fcdataAA$USDJPY.Low)^2))
paste('Close = ', mean((fcdataAA$USDJPY.FPCL.Close - fcdataAA$USDJPY.Close)^2))
```

```{r combine-dataETS}
fcdata <- do.call(cbind, list(USDJPY.FPOP.Open = fitETS.op$Point.Forecast, 
                              USDJPY.FPHI.High = fitETS.hi$Point.Forecast, 
                              USDJPY.FPMN.Mean = fitETS.mn$Point.Forecast, 
                              USDJPY.FPLO.Low = fitETS.lo$Point.Forecast, 
                              USDJPY.FPCL.Close = fitETS.cl$Point.Forecast, 
                              USDJPY.Open = fitETS.op$USDJPY.Open, 
                              USDJPY.High = fitETS.op$USDJPY.High, 
                              USDJPY.Low = fitETS.op$USDJPY.Low, 
                              USDJPY.Close = fitETS.op$USDJPY.Close))
fcdata <- na.omit(fcdata)
names(fcdata) <- c('USDJPY.FPOP.Open', 'USDJPY.FPHI.High', 'USDJPY.FPMN.Mean', 
                   'USDJPY.FPLO.Low', 'USDJPY.FPCL.Close', 'USDJPY.Open', 
                   'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')

## Mean Squared Error : comparison of accuracy
paste('Open = ', mean((fcdata$USDJPY.FPOP.Open - fcdata$USDJPY.Open)^2))
paste('High = ', mean((fcdata$USDJPY.FPHI.High - fcdata$USDJPY.High)^2))
paste('Mean = ', mean((fcdata$USDJPY.FPMN.Mean - (fcdata$USDJPY.High + fcdata$USDJPY.Low)/2)^2))
paste('Low = ', mean((fcdata$USDJPY.FPLO.Low - fcdata$USDJPY.Low)^2))
paste('Close = ', mean((fcdata$USDJPY.FPCL.Close - fcdata$USDJPY.Close)^2))
```

#### 2.1.2.2 Garch vs EWMA

  Basically for volatility analyzing, we can using RSY Volatility mesure, kindly refer to *Analyzing Financial Data and Implementing Financial Models using R*^[paper 22] for more information. Well, Garch model is designate for forecast volatility.

  Now we look at Garch model, *Figlewski (2004)*^[*Paper 19th*] applied few models and also using different length of data for comparison. Now I use daily Hi-Lo and 365 days data in order to predict the next market price. The author applid Garch on SAP200, 10-years-bond and 20-years-bond and concludes that the Garch model is better than eGarch but implied volatility model better than Garch and eGarch, and the monthly Hi-Lo data is better accurate than daily Hi-Lo for long term investment.

<iframe width="560" height="315" src="https://www.youtube.com/embed/wsYXKh_xmSs" frameborder="0" allowfullscreen></iframe>

$$h_{t} = {\omega} + \sum_{i=1}^q{{\alpha}_{i} {\epsilon}_{t-i}^2} + \sum_{j=1}^p{{\gamma}_{j} h_{t-j}}\ \dots equation\ 2.1.2.2.1$$

  - [<span style='color:blue'>Volatility Forecasting Using GARCH(1,1)</span>](https://quantumfinancier.wordpress.com/2010/08/26/volatility-forecasting-using-garch11/)
  - [<span style='color:blue'>Regime Switching System Using Volatility Forecast</span>](https://quantumfinancier.wordpress.com/2010/08/27/regime-switching-system-using-volatility-forecast/)
  - [<span style='color:blue'>Normalized Price Spread Strategy</span>](https://quantumfinancier.wordpress.com/2010/06/17/normalized-price-spread-strategy/)
  - [<span style='color:blue'>Volatility Autocorrelation in Different Markets</span>](https://quantumfinancier.wordpress.com/2010/05/27/volatility-autocorrelation-in-different-markets/)
  - [<span style='color:blue'>Basic Introduction to GARCH and EGARCH (part 1)</span>](https://quantumfinancier.wordpress.com/2010/09/12/381/)
  - [<span style='color:blue'>Basic Introduction to GARCH and EGARCH (part 2)</span>](https://quantumfinancier.wordpress.com/2010/09/14/basic-introduction-to-garch-and-egarch-part-2/)
  - [<span style='color:blue'>Basic Introduction to GARCH and EGARCH (Part 3)</span>](http://quantumfinancier.wordpress.com/2010/09/23/basic-introduction-to-garch-and-egarch-part-3/amp)^[Using this EGARCH model, we can epect a better estimate the volatility for assets returns due to how the EGARCH counteracts the limitations on the classic GARCH model.Here is the final part of the series of posts on the volatility modelling where I will briefly talk about one of the many variant of the GARCH model: the exponential GARCH (abbreviated EGARCH). I chose this variant because it improves the GARCH model and better model some market mechanics. In the GARCH post, I didn’t mention any of the limitation of the model as I kept them for today’s post. First of all, the GARCH model assume that only the magnitude of unanticipated excess returns determines $\sigma^2_t$. Intuitively, we can question this assumption; I, for one, would argue that not only the magnitude but also the direction of the returns affects volatility.]
  - [<span style='color:blue'>Analysis List</span>](https://vlab.stern.nyu.edu/doc?topic=mdls)
  
    - Volatility Analysis
    
      + [<span style='color:blue'>AGARCH](https://vlab.stern.nyu.edu/doc/6?topic=mdls</span>)
      + [<span style='color:blue'>APARCH</span>](https://vlab.stern.nyu.edu/doc/5?topic=mdls)
      + [<span style='color:blue'>Asy. MEM</span>](https://vlab.stern.nyu.edu/doc/10?topic=mdls)
      + [<span style='color:blue'>Asy. Power MEM</span>](https://vlab.stern.nyu.edu/doc/11?topic=mdls)
      + [<span style='color:blue'>CDS-GARCH</span>](https://vlab.stern.nyu.edu/doc/25?topic=mdls)
      + [<span style='color:blue'>CDS-GARCH-DYN</span>](https://vlab.stern.nyu.edu/doc/26?topic=mdls)
      + [<span style='color:blue'>EGARCH</span>](https://vlab.stern.nyu.edu/doc/4?topic=mdls)
      + [<span style='color:blue'>GARCH</span>](https://vlab.stern.nyu.edu/doc/2?topic=mdls)
      + [<span style='color:blue'>GAS-GARCH Student T</span>](https://vlab.stern.nyu.edu/doc/23?topic=mdls)
      + [<span style='color:blue'>GJR-GARCH</span>](https://vlab.stern.nyu.edu/doc/3?topic=mdls)
      + [<span style='color:blue'>MEM</span>](https://vlab.stern.nyu.edu/doc/9?topic=mdls)
      + [<span style='color:blue'>Spline-GARCH</span>](https://vlab.stern.nyu.edu/doc/7?topic=mdls)
      + [<span style='color:blue'>Zero Slope Spline-GARCH</span>](https://vlab.stern.nyu.edu/doc/8?topic=mdls)
      
    - Correlation Analysis
    
      + [<span style='color:blue'>EWMA Covariance</span>](https://vlab.stern.nyu.edu/doc/12?topic=mdls)
      + [<span style='color:blue'>GARCH-DCC</span>](https://vlab.stern.nyu.edu/doc/13?topic=mdls)
      + [<span style='color:blue'>GARCH-DECO</span>](https://vlab.stern.nyu.edu/doc/20?topic=mdls)
      + [<span style='color:blue'>GJR-DCC</span>](https://vlab.stern.nyu.edu/doc/14?topic=mdls)
      + [<span style='color:blue'>GJR-DECO</span>](https://vlab.stern.nyu.edu/doc/21?topic=mdls)
      
    - Systemic Risk Analysis
    
      + [<span style='color:blue'>Domestic MES</span>](https://vlab.stern.nyu.edu/doc/40?topic=mdls)
      + [<span style='color:blue'>Dynamic MES</span>](https://vlab.stern.nyu.edu/doc/16?topic=mdls)
      + [<span style='color:blue'>Dynamic MES with Simulation</span>](https://vlab.stern.nyu.edu/doc/22?topic=mdls)
      + [<span style='color:blue'>Global Dynamic MES</span>](https://vlab.stern.nyu.edu/doc/17?topic=mdls)
      
    - Long Run Value at Risk
    
      + [<span style='color:blue'>Long Term GJR-GARCH Forecast</span>](https://vlab.stern.nyu.edu/doc/18?topic=mdls)
      + [<span style='color:blue'>Long Term GJR-GARCH Forecast with Options</span>](https://vlab.stern.nyu.edu/doc/19?topic=mdls)
      
    - Liquidity Analysis
    
      + [<span style='color:blue'>Asymmetric ILLIQ</span>](https://vlab.stern.nyu.edu/doc/28?topic=mdls)
      + [<span style='color:blue'>Historical ILLIQ</span>](https://vlab.stern.nyu.edu/doc/29?topic=mdls)
      + [<span style='color:blue'>Spline ILLIQ</span>](https://vlab.stern.nyu.edu/doc/27?topic=mdls)
      
    - Fixed Income Analysis
    
      + [<span style='color:blue'>ESR Interest Rate Forecast</span>](https://vlab.stern.nyu.edu/doc/39?topic=mdls)

  - [<span style='color:blue'>Extensions of the GARCH Model</span>](http://sfb649.wiwi.hu-berlin.de/fedc_homepage/xplore/tutorials/sfehtmlnode67.html)^[Comparison among the GARCH, TGARCH (Threshold GARCH) and EGARCH (Exponential GARCH) models.]
  - [<span style='color:blue'>How to fit ARMA+GARCH Model In R?</span>](https://quant.stackexchange.com/questions/4948/how-to-fit-armagarch-model-in-r?answertab=votes#tab-top)
  - [<span style='color:blue'>A short introduction to the rugarch package</span>](http://unstarched.net/r-examples/rugarch/a-short-introduction-to-the-rugarch-package/)
  - [<span style='color:blue'>A practical introduction to garch modeling</span>](https://www.r-bloggers.com/a-practical-introduction-to-garch-modeling/)
  - [<span style='color:blue'>ARCH-GARCH Example with R</span>](http://yunus.hacettepe.edu.tr/~iozkan/eco665/archgarch.html)
  - [<span style='color:blue'>Financial Econometrics Practical *Practical 6: Univariate Volatility Modelling*</span>](http://curiousquant.com/ClassNotes/FinMetrics/Practicals/Practical_6/Practical_6.html)
  - [<span style='color:blue'>Multivariate GARCH(1,1) in R</span>](https://stackoverflow.com/questions/35035857/multivariate-garch1-1-in-r?answertab=votes#tab-top)
  - [<span style='color:blue'>R - Modelling Multivariate GARCH (rugarch and ccgarch)</span>](https://stackoverflow.com/questions/16874375/r-modelling-multivariate-garch-rugarch-and-ccgarch?answertab=votes#tab-top)
  - [<span style='color:blue'>Introduction to some R package</span>](./reference/Introduction to some R packages.pdf)
  - [<span style='color:blue'>Introduction to the ruGarch package</span>](./reference/Introduction to the rugarch package.pdf)
  - [<span style='color:blue'>The rmgarch models: Background and properties. - R Project</span>](./reference/The rmgarch models - Background and Properties.pdf)
  - [<span style='color:blue'>rmgarch - How to Multivariate GARCH Models in R | R-How.com</span>](https://r-how.com/packages/rmgarch)
  - [<span style='color:blue'>Volatility forecast evaluation in R</span>](https://eranraviv.com/volatility-forecast-evaluation-in-r/)

  Firstly we use `rugarch` <s>and then `rmgarch`</s>^[Due to file loading heavily, here I leave the multivariate Garch models for future works.] to compare the result.

```{r intro-Garch}
## http://www.unstarched.net/r-examples/rugarch/a-short-introduction-to-the-rugarch-package/
ugarchspec()

## This defines a basic ARMA(1,1)-GARCH(1,1) model, though there are many more options to choose from ranging from the type of GARCH model, the ARFIMAX-arch-in-mean specification and conditional distribution. In fact, and considering only the (1,1) order for the GARCH and ARMA models, there are 13440 possible combinations of models and model options to choose from:

## possible Garch models.
nrow(expand.grid(GARCH = 1:14, VEX = 0:1, VT = 0:1, Mean = 0:1, ARCHM = 0:2, ARFIMA = 0:1, MEX = 0:1, DISTR = 1:10))

spec = ugarchspec(variance.model = list(model = 'eGARCH', garchOrder = c(2, 1)), distribution = 'std')
```

  There will be `r nrow(expand.grid(GARCH = 1:14, VEX = 0:1, VT = 0:1, Mean = 0:1, ARCHM = 0:2, ARFIMA = 0:1, MEX = 0:1, DISTR = 1:10))` possible combination Garch models. Here I tried to filter few among them.

  Now we try to build a Garch model and will build some Garch models to get the best fit in later section.

<iframe width="560" height="315" src="https://www.youtube.com/embed/0q3gSJKJUs8" frameborder="0" allowfullscreen></iframe>

```{r build-Garch}
## Modelling Garch ('sGarch' model) focasting data.
#'@ fitGM.op <- suppressAll(simGarch(USDJPY, .prCat = 'Op')) #will take a minute
#'@ saveRDS(fitGM.op, './data/fitGM.op.rds')

#'@ fitGM.hi <- suppressAll(simGarch(USDJPY, .prCat = 'Hi')) #will take a minute
#'@ saveRDS(fitGM.hi, './data/fitGM.hi.rds')

#'@ fitGM.mn <- suppressAll(simGarch(USDJPY, .prCat = 'Mn')) #will take a minute
#'@ saveRDS(fitGM.mn, './data/fitGM.mn.rds')

#'@ fitGM.lo <- suppressAll(simGarch(USDJPY, .prCat = 'Lo')) #will take a minute
#'@ saveRDS(fitGM.lo, './data/fitGM.lo.rds')

#'@ fitGM.cl <- suppressAll(simGarch(USDJPY, .prCat = 'Cl')) #will take a minute
#'@ saveRDS(fitGM.cl, './data/fitGM.cl.rds')

fitGM.op <- readRDS('./data/fitGM.op.rds')
fitGM.hi <- readRDS('./data/fitGM.hi.rds')
fitGM.mn <- readRDS('./data/fitGM.mn.rds')
fitGM.lo <- readRDS('./data/fitGM.lo.rds')
fitGM.cl <- readRDS('./data/fitGM.cl.rds')
```

```{r intro-EWMA, warning = FALSE}
## ======================== eval = FALSE ==============================

## Exponential Weighted Moving Average model - EWMA fixed parameters
#'@ ewma.spec.fixed <- llply(pp, function(y) {
#'@   z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = y[1], 
#'@                      .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
#'@                      .parallel = FALSE, .progress = 'text', 
#'@                      .setPrice = y[2], .setPrice.method = 'CSS-ML', 
#'@                      .initialFundSize = 1000, .fundLeverageLog = FALSE, 
#'@                      .filterBets = FALSE, .variance.model = list(
#'@                        model = .variance.model.par[6], garchOrder = c(1, 1), 
#'@                        submodel = NULL, external.regressors = NULL, 
#'@                        variance.targeting = FALSE), 
#'@                      .mean.model = list(armaOrder = c(1, 1), 
#'@                                         include.mean = TRUE, 
#'@                                         archm = FALSE, archpow = 1, 
#'@                                         arfima = FALSE, 
#'@                                         external.regressors = NULL, 
#'@                                         archex = FALSE), 
#'@                      .dist.model = .dist.model.par[1], start.pars = list(), 
#'@                      fixed.pars = list(alpha1 = 1 - 0.94, omega = 0))
#'@   
#'@   txt1 <- paste0('saveRDS(z', ', file = \'./data/', 
#'@                  .variance.model.par[6], '.EWMA.fixed.', 
#'@                  y[1], '.', y[2], '.', .dist.model.par[1], '.', 
#'@                  .solver.par[1], '.rds\')')
#'@   eval(parse(text = txt1))
#'@   cat(paste0(txt1, ' done!', '\n'))
#'@   rm(z)
#'@ })

## Exponential Weighted Moving Average model - EWMA estimated parameters
#'@ ewma.spec.est <- llply(pp, function(y) {
#'@   z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = y[1], 
#'@                      .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
#'@                      .parallel = FALSE, .progress = 'text', 
#'@                      .setPrice = y[2], .setPrice.method = 'CSS-ML', 
#'@                      .initialFundSize = 1000, .fundLeverageLog = FALSE, 
#'@                      .filterBets = FALSE, .variance.model = list(
#'@                        model = .variance.model.par[6], garchOrder = c(1, 1), 
#'@                        submodel = NULL, external.regressors = NULL, 
#'@                        variance.targeting = FALSE), 
#'@                      .mean.model = list(armaOrder = c(1, 1), 
#'@                                         include.mean = TRUE, 
#'@                                         archm = FALSE, archpow = 1, 
#'@                                         arfima = FALSE, 
#'@                                         external.regressors = NULL, 
#'@                                         archex = FALSE), 
#'@                      .dist.model = .dist.model.par[1], start.pars = list(), 
#'@                      fixed.pars = list(omega = 0))
#'@   
#'@   txt1 <- paste0('saveRDS(z', ', file = \'./data/', 
#'@                  .variance.model.par[6], '.EWMA.est.', 
#'@                  y[1], '.', y[2], '.', .dist.model.par[1], '.', 
#'@                  .solver.par[1], '.rds\')')
#'@   eval(parse(text = txt1))
#'@   cat(paste0(txt1, ' done!', '\n'))
#'@   rm(z)
#'@ })

## itegration Garch model - iGarch
#'@ igarch.spec <- llply(pp, function(y) {
#'@   z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = y[1], 
#'@                      .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
#'@                      .parallel = FALSE, .progress = 'text', 
#'@                      .setPrice = y[2], .setPrice.method = 'CSS-ML', 
#'@                      .initialFundSize = 1000, .fundLeverageLog = FALSE, 
#'@                      .filterBets = FALSE, .variance.model = list(
#'@                        model = .variance.model.par[6], garchOrder = c(1, 1), 
#'@                        submodel = NULL, external.regressors = NULL, 
#'@                        variance.targeting = FALSE), 
#'@                      .mean.model = list(armaOrder = c(1, 1), 
#'@                                         include.mean = TRUE, 
#'@                                         archm = FALSE, archpow = 1, 
#'@                                         arfima = FALSE, 
#'@                                         external.regressors = NULL, 
#'@                                         archex = FALSE), 
#'@                      .dist.model = .dist.model.par[1], start.pars = list(), 
#'@                      fixed.pars = list())
#'@   
#'@   txt1 <- paste0('saveRDS(z', ', file = \'./data/', 
#'@                  .variance.model.par[6], '.', y[1], '.', y[2], '.', 
#'@                  .dist.model.par[1], '.', .solver.par[1], '.rds\')')
#'@   eval(parse(text = txt1))
#'@   cat(paste0(txt1, ' done!', '\n'))
#'@   rm(z)
#'@ })
```

**Application of MCMC**

  Need to refer to MCMC since I am using Garch models...

  - [<span style='color:blue'>Markov Chain Monte Carlo Method</span>](https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_introbayes_sect007.htm)
  - [<span style='color:blue'>Burn-In is Unnecessary</span>](http://users.stat.umn.edu/~geyer/mcmc/burn.html)
  - [<span style='color:blue'>**Nice R Code** *Punning code better since 2013*</span>](https://nicercode.github.io/guides/mcmc/)

```{r lm-Garch}
## Here I test the accuracy of forecasting of univariate Garch ('sGarch' model) models.

## Test the models
## opened price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitGM.op))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitGM.op))

## highest price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitGM.hi))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitGM.hi))

## mean price fit data (mean price of daily highest and lowest price)
summary(lm(Point.Forecast~ USDJPY.Close, data = fitGM.mn))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitGM.mn))

## lowest price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitGM.lo))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitGM.lo))

## closed price fit data
summary(lm(Point.Forecast~ USDJPY.Close, data = fitGM.cl))
summary(MCMCregress(Point.Forecast~ USDJPY.Close, data = fitGM.cl))
```

**Mean Squared Error**

```{r combine-dataGM}
## Univariate Garch models.
fcdataGM <- do.call(cbind, list(USDJPY.FPOP.Open = fitGM.op$Point.Forecast, 
                              USDJPY.FPHI.High = fitGM.hi$Point.Forecast, 
                              USDJPY.FPMN.Mean = fitGM.mn$Point.Forecast, 
                              USDJPY.FPLO.Low = fitGM.lo$Point.Forecast, 
                              USDJPY.FPCL.Close = fitGM.cl$Point.Forecast, 
                              USDJPY.Open = fitGM.op$USDJPY.Open, 
                              USDJPY.High = fitGM.op$USDJPY.High, 
                              USDJPY.Low = fitGM.op$USDJPY.Low, 
                              USDJPY.Close = fitGM.op$USDJPY.Close))
fcdataGM <- na.omit(fcdataGM)
names(fcdataGM) <- c('USDJPY.FPOP.Open', 'USDJPY.FPHI.High', 'USDJPY.FPMN.Mean', 
                   'USDJPY.FPLO.Low', 'USDJPY.FPCL.Close', 'USDJPY.Open', 
                   'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')

## Mean Squared Error : comparison of accuracy
paste('Open = ', mean((fcdataGM$USDJPY.FPOP.Open - fcdataGM$USDJPY.Open)^2))
paste('High = ', mean((fcdataGM$USDJPY.FPHI.High - fcdataGM$USDJPY.High)^2))
paste('Mean = ', mean((fcdataGM$USDJPY.FPMN.Mean - (fcdataGM$USDJPY.High + fcdataGM$USDJPY.Low)/2)^2))
paste('Low = ', mean((fcdataGM$USDJPY.FPLO.Low - fcdataGM$USDJPY.Low)^2))
paste('Close = ', mean((fcdataGM$USDJPY.FPCL.Close - fcdataGM$USDJPY.Close)^2))
```

#### 2.1.2.3 MCMC vs Bayesian Time Series

  Generally, we can write a Bayesian structural model like this:

$$Y_{t} = \mu_{t}+x_{t}\beta + S_{t}+e_{t}\ ,\ e_{t}∼N(0,\sigma_{e}_{2})$$
$$\mu_{t} + 1 = \mu_{t} + \nu_{t}\ ,\ \nu_{t}∼N(0,\sigma_{\nu}_{2})$$

  For bayesian and MCMC, I leave it for future works.

```{r bsts}
## Sorry ARIMA, but I’m Going Bayesian (packages : bsts, arm)
## http://multithreaded.stitchfix.com/blog/2016/04/21/forget-arima/
## https://stackoverflow.com/questions/11839886/r-predict-glm-equivalent-for-mcmcpackmcmclogit
```

#### 2.1.2.4 MIDAS

  For Midas, I also leave it for future works. Kindly refer to [<span style='color:blue'>Mixed Frequency Data Sampling Regression Models - The R Package midasr</span>](https://raw.githubusercontent.com/englianhu/binary.com-interview-question/757b27e1e93132368b0898152078be4961b05a28/reference/Mixed%20Frequency%20Data%20Sampling%20Regression%20Models%20-%20The%20R%20Package%20midasr.pdf) for more information about Midas.

### 2.1.3 Data Visualization

  Plot graph.

#### 2.1.3.1 ARIMA vs ETS

```{r plotETS-1, echo = FALSE}
## Plot the models
## opened price fit data
autoplot(forecast(ets(fitETS.op$Point.Forecast), h = 4), facets = TRUE) + geom_forecast(color = '#ffcccc', show.legend = FALSE) + labs(x = 'Day', y = 'Forex Price', title = 'Forecasts from ETS model [A,N,N]', subtitle = 'Opening Price Forecast', caption = 'Source : USDJPY')

#'@ ggplot(data = pd, aes(x = date, y = observed)) + geom_line(color = 'red') + geom_line(aes(y = fitted), color = "blue") + geom_line(aes(y = forecast)) + geom_ribbon(aes(ymin = lo95, ymax = hi95), alpha = .25) + scale_x_date(name = "Time in Decades") + scale_y_continuous(name = "GDP per capita (current US$)") + theme(axis.text.x = element_text(size = 10), legend.justification=c(0,1), legend.position=c(0,1)) + ggtitle("Arima(0,1,1) Fit and Forecast of GDP per capita for Brazil (1960-2013)") + scale_color_manual(values = c("Blue", "Red"), breaks = c("Fitted", "Data", "Forecast")) + ggsave((filename = "gdp_forecast_ggplot.pdf"), width=330, height=180, units=c("mm"), dpi = 300, limitsize = TRUE)

## highest price fit data
autoplot(forecast(ets(fitETS.hi$Point.Forecast), h = 4), facets = TRUE) + geom_forecast(color = '#FFCCCC', show.legend = FALSE) + labs(x = 'Day', y = 'Forex Price', title = 'Forecasts from ETS model [A,N,N]', subtitle = 'Highest Price Forecast', caption = 'Source : USDJPY')

## mean price fit data (mean price of daily highest and lowest price)
autoplot(forecast(ets(fitETS.mn$Point.Forecast), h = 4), facets = TRUE) + geom_forecast(color = '#FFCCCC', show.legend = FALSE) + labs(x = 'Day', y = 'Forex Price', title = 'Forecasts from ETS model [A,N,N]', subtitle = 'Mean Price Forecast', caption = 'Source : USDJPY')

## lowest price fit data
autoplot(forecast(ets(fitETS.lo$Point.Forecast), h = 4), facets = TRUE) + geom_forecast(color = '#FFCCCC', show.legend = FALSE) + labs(x = 'Day', y = 'Forex Price', title = 'Forecasts from ETS model [A,N,N]', subtitle = 'Lowest Price Forecast', caption = 'Source : USDJPY')

## opened price fit data
autoplot(forecast(ets(fitETS.cl$Point.Forecast), h = 4), facets = TRUE) + geom_forecast(color = '#FFCCCC', show.legend = FALSE) + labs(x = 'Day', y = 'Forex Price', title = 'Forecasts from ETS model [A,N,N]', subtitle = 'Closing Price Forecast', caption = 'Source : USDJPY')
```

```{r plotETS-2, echo = FALSE}
#'@ source('./function/plotChart2.R', local = TRUE)
suppressAll(rm(fitETS.op, fitETS.hi, fitETS.mn, fitETS.lo, fitETS.cl))

plotChart2(fcdata, initialName = 'FP', chart.type = 'FP', graph.title = 'ETS Model : USDJPY')
```

#### 2.1.3.2 Garch vs EWMA

```{r plotGM-1, echo = FALSE}
#'@ source('./function/plotChart2.R', local = TRUE)
suppressAll(rm(fitGM.op, fitGM.hi, fitGM.mn, fitGM.lo, fitGM.cl))

plotChart2(fcdataGM, initialName = 'FP', chart.type = 'FP', graph.title = 'Garch Model : USDJPY')
```

#### 2.1.3.3 MCMC vs Bayesian Time Series


#### 2.1.3.4 MIDAS



### 2.1.4 Staking Model

#### 2.1.4.1 ARIMA vs ETS

  Staking function. Here I apply Kelly criterion as the betting strategy. I don't pretend to know the order of price flutuation flow from the Hi-Lo price range, therefore I just using Closing price for settlement while the staking price restricted within the variance (Hi-Lo) to made the transaction stand. The settled price can only be closing price unless staking price is opening price which sellable within the Hi-Lo range.
  
  Due to we cannot know the forecasted sell/buy price and also forecasted closing price which is coming first solely from Hi-Lo data, therefore the Profit&Loss will slidely different (sell/buy price = forecasted sell/buy price).
  
  - Forecasted profit = edge based on forecasted sell/buy price - forecasted settled price.
  - If the forecasted sell/buy price doesn't exist within the Hi-Lo price, then the transaction is not stand.
  - If the forecasted settled price does not exist within the Hi-Lo price, then the settled price will be the real closing price.

  Kindly refer to [<span style='color:blue'>**Quintuitive** ARMA Models for Trading</span>](http://www.quintutive.com2012/08/22/arma-models-for-trading) to know how to determine PULL or CALL with ARMA models^[The author compare the ROI between **Buy-and-Hold** with **GARCH** model.].

  Here I set an application of leverage while it is very risky (the variance of ROI is very high) as we can know from later comparison.

**Staking Model**

  For Buy-Low-Sell-High tactic, I placed two limit order for tomorrow now, which are buy and sell. The transaction will be standed once the price hit in tomorrow. If the buy price doesn't met, there will be no transaction made, while sell price doesn't occur will use closing price for settlement.^[Using Kelly criterion staking model]

  For variance betting, I used both focasted highest minus the forecasted lowest price to get the range. After that placed two limit orders as well. If one among the buy or sell price doesn't appear will use closing price as final settlement.^[Place $100 for every single bet.]

#### 2.1.4.2 Garch vs EWMA

  The staking models same with what I applied onto ETS modelled dataset.

#### 2.1.4.3 MCMC vs Bayesian Time Series


#### 2.1.4.4 MIDAS


### 2.1.5 Return of Investment

#### 2.1.5.1 ARIMA vs ETS

```{r simStaking-AutoArima, eval = FALSE, include = FALSE}
##============================ EVAL = FALSE ================================
## 
## Model 1 without leverage.
## 
## Placed orders - Fund size without log

#'@ mbase <- USDJPY

## settled with highest price.
fundAutoArimaOPHI <- simStakesAutoArima(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundAutoArimaOPHI, file = './data/fundAutoArimaOPHI.rds')

fundAutoArimaHIHI <- simStakesAutoArima(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundAutoArimaHIHI, file = './data/fundAutoArimaHIHI.rds')

fundAutoArimaMNHI <- simStakesAutoArima(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundAutoArimaMNHI, file = './data/fundAutoArimaMNHI.rds')

fundAutoArimaLOHI <- simStakesAutoArima(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundAutoArimaLOHI, file = './data/fundAutoArimaLOHI.rds')

fundAutoArimaCLHI <- simStakesAutoArima(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundAutoArimaCLHI, file = './data/fundAutoArimaCLHI.rds')


## settled with mean price.
fundAutoArimaOPMN <- simStakesAutoArima(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundAutoArimaOPMN, file = './data/fundAutoArimaOPMN.rds')

fundAutoArimaHIMN <- simStakesAutoArima(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundAutoArimaHIMN, file = './data/fundAutoArimaHIMN.rds')

fundAutoArimaMNMN <- simStakesAutoArima(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundAutoArimaMNMN, file = './data/fundAutoArimaMNMN.rds')

fundAutoArimaLOMN <- simStakesAutoArima(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundAutoArimaLOMN, file = './data/fundAutoArimaLOMN.rds')

fundAutoArimaCLMN <- simStakesAutoArima(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundAutoArimaCLMN, file = './data/fundAutoArimaCLMN.rds')


## settled with opening price.
fundAutoArimaOPLO <- simStakesAutoArima(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundAutoArimaOPLO, file = './data/fundAutoArimaOPLO.rds')

fundAutoArimaHILO <- simStakesAutoArima(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundAutoArimaHILO, file = './data/fundAutoArimaHILO.rds')

fundAutoArimaMNLO <- simStakesAutoArima(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundAutoArimaMNLO, file = './data/fundAutoArimaMNLO.rds')

fundAutoArimaLOLO <- simStakesAutoArima(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundAutoArimaLOLO, file = './data/fundAutoArimaLOLO.rds')

fundAutoArimaCLLO <- simStakesAutoArima(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundAutoArimaCLLO, file = './data/fundAutoArimaCLLO.rds')


## settled with closing price.
fundAutoArimaOPCL <- simStakesAutoArima(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundAutoArimaOPCL, file = './data/fundAutoArimaOPCL.rds')

fundAutoArimaHICL <- simStakesAutoArima(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundAutoArimaHICL, file = './data/fundAutoArimaHICL.rds')

fundAutoArimaMNCL <- simStakesAutoArima(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundAutoArimaMNCL, file = './data/fundAutoArimaMNCL.rds')

fundAutoArimaLOCL <- simStakesAutoArima(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundAutoArimaLOCL, file = './data/fundAutoArimaLOCL.rds')

fundAutoArimaCLCL <- simStakesAutoArima(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundAutoArimaCLCL, file = './data/fundAutoArimaCLCL.rds')

## Placed orders - Fund size without log
fundList <- list(fundOPHI = fundAutoArimaOPHI, fundHIHI = fundAutoArimaHIHI, fundMNHI = fundAutoArimaMNHI, fundLOHI = fundAutoArimaLOHI, fundCLHI = fundAutoArimaCLHI, 
                fundOPMN = fundAutoArimaOPMN, fundHIMN = fundAutoArimaHIMN, fundMNMN = fundAutoArimaMNMN, fundLOMN = fundAutoArimaLOMN, fundCLMN = fundAutoArimaCLMN, 
                fundOPLO = fundAutoArimaOPLO, fundHILO = fundAutoArimaHILO, fundMNLO = fundAutoArimaMNLO, fundLOLO = fundAutoArimaLOLO, fundCLLO = fundAutoArimaCLLO, 
                fundOPCL = fundAutoArimaOPCL, fundHICL = fundAutoArimaHICL, fundMNCL = fundAutoArimaMNCL, fundLOCL = fundAutoArimaLOCL, fundCLCL = fundAutoArimaCLCL)

ldply(fundList, function(x) { x %>% mutate(StartDate = first(Date), LatestDate = last(Date), InitFund = first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
# A tibble: 20 x 7
#         .id  StartDate LatestDate InitFund LatestFund    Profit       RR
#       <chr>     <date>     <date>    <dbl>      <dbl>     <dbl>    <dbl>
#  1 fundOPHI 2015-01-02 2017-01-20     1000   1325.983 325.98313 1.325983
#  2 fundHIHI 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
#  3 fundMNHI 2015-01-02 2017-01-20     1000   1236.199 236.19900 1.236199
#  4 fundLOHI 2015-01-02 2017-01-20     1000   1716.985 716.98492 1.716985
#  5 fundCLHI 2015-01-02 2017-01-20     1000   1323.688 323.68809 1.323688
#  6 fundOPMN 2015-01-02 2017-01-20     1000   1304.819 304.81916 1.304819
#  7 fundHIMN 2015-01-02 2017-01-20     1000   1363.714 363.71443 1.363714
#  8 fundMNMN 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
#  9 fundLOMN 2015-01-02 2017-01-20     1000   1440.170 440.16965 1.440170
# 10 fundCLMN 2015-01-02 2017-01-20     1000   1292.947 292.94694 1.292947
# 11 fundOPLO 2015-01-02 2017-01-20     1000   1307.610 307.60951 1.307610
# 12 fundHILO 2015-01-02 2017-01-20     1000   1637.251 637.25113 1.637251
# 13 fundMNLO 2015-01-02 2017-01-20     1000   1250.375 250.37547 1.250375
# 14 fundLOLO 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
# 15 fundCLLO 2015-01-02 2017-01-20     1000   1261.157 261.15684 1.261157
# 16 fundOPCL 2015-01-02 2017-01-20     1000   1047.563  47.56281 1.047563
# 17 fundHICL 2015-01-02 2017-01-20     1000   1401.694 401.69378 1.401694
# 18 fundMNCL 2015-01-02 2017-01-20     1000   1158.790 158.79028 1.158790
# 19 fundLOCL 2015-01-02 2017-01-20     1000   1499.818 499.81773 1.499818
# 20 fundCLCL 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
```

```{r ROI-AutoArima, echo = FALSE}
## load the pre-run and saved models.
## Profit and Loss of Arima models.

flsAutoArima <- dir('./data', pattern = 'fundAutoArima')

fundList <- llply(flsAutoArima, function(dt) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
          readRDS(file = paste0('./data/', dt))) %>% tbl_df
  })
names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))

## Summary of ROI
aa.tbl <- ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df

aa.tbl %>% kable(width = 'auto')
```

  The return of investment from best fitted Auto Arima model.

```
 7 fundAutoArimaHILO 2015-01-02 2017-01-20     1000   1637.251 637.25113 1.637251
10 fundAutoArimaLOHI 2015-01-02 2017-01-20     1000   1716.985 716.98492 1.716985
```

  Profit and Loss of default `ZZZ` ets models.

```{r simStaking-woutLog, warning = FALSE}
## 
## Model 1 without leverage.
## 
## Placed orders - Fund size without log

#'@ mbase <- USDJPY

## settled with highest price.
#'@ fundOPHI <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = 1000)
#'@ saveRDS(fundOPHI, file = './data/fundOPHI.rds')

#'@ fundHIHI <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = 1000)
#'@ saveRDS(fundHIHI, file = './data/fundHIHI.rds')

#'@ fundMNHI <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = 1000)
#'@ saveRDS(fundMNHI, file = './data/fundMNHI.rds')

#'@ fundLOHI <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = 1000)
#'@ saveRDS(fundLOHI, file = './data/fundLOHI.rds')

#'@ fundCLHI <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = 1000)
#'@ saveRDS(fundCLHI, file = './data/fundCLHI.rds')


## settled with mean price.
#'@ fundOPMN <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = 1000)
#'@ saveRDS(fundOPMN, file = './data/fundOPMN.rds')

#'@ fundHIMN <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = 1000)
#'@ saveRDS(fundHIMN, file = './data/fundHIMN.rds')

#'@ fundMNMN <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = 1000)
#'@ saveRDS(fundMNMN, file = './data/fundMNMN.rds')

#'@ fundLOMN <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = 1000)
#'@ saveRDS(fundLOMN, file = './data/fundLOMN.rds')

#'@ fundCLMN <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = 1000)
#'@ saveRDS(fundCLMN, file = './data/fundCLMN.rds')


## settled with opening price.
#'@ fundOPLO <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = 1000)
#'@ saveRDS(fundOPLO, file = './data/fundOPLO.rds')

#'@ fundHILO <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = 1000)
#'@ saveRDS(fundHILO, file = './data/fundHILO.rds')

#'@ fundMNLO <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = 1000)
#'@ saveRDS(fundMNLO, file = './data/fundMNLO.rds')

#'@ fundLOLO <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = 1000)
#'@ saveRDS(fundLOLO, file = './data/fundLOLO.rds')

#'@ fundCLLO <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = 1000)
#'@ saveRDS(fundCLLO, file = './data/fundCLLO.rds')


## settled with closing price.
#'@ fundOPCL <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = 1000)
#'@ saveRDS(fundOPCL, file = './data/fundOPCL.rds')

#'@ fundHICL <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = 1000)
#'@ saveRDS(fundHICL, file = './data/fundHICL.rds')

#'@ fundMNCL <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = 1000)
#'@ saveRDS(fundMNCL, file = './data/fundMNCL.rds')

#'@ fundLOCL <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = 1000)
#'@ saveRDS(fundLOCL, file = './data/fundLOCL.rds')

#'@ fundCLCL <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = 1000)
#'@ saveRDS(fundCLCL, file = './data/fundCLCL.rds')

## Placed orders - Fund size without log
#'@ fundList <- list(fundOPHI = fundOPHI, fundHIHI = fundHIHI, fundMNHI = fundMNHI, fundLOHI = fundLOHI, fundCLHI = fundCLHI, 
#'@                 fundOPMN = fundOPMN, fundHIMN = fundHIMN, fundMNMN = fundMNMN, fundLOMN = fundLOMN, fundCLMN = fundCLMN, 
#'@                 fundOPLO = fundOPLO, fundHILO = fundHILO, fundMNLO = fundMNLO, fundLOLO = fundLOLO, fundCLLO = fundCLLO, 
#'@                 fundOPCL = fundOPCL, fundHICL = fundHICL, fundMNCL = fundMNCL, fundLOCL = fundLOCL, fundCLCL = fundCLCL)

#'@ ldply(fundList, function(x) { x %>% mutate(StartDate = first(Date), LatestDate = last(Date), InitFund = first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
## A tibble: 20 × 5
#        .id  StartDate LatestDate  InitFund LatestFund     Profit        RR
#      <chr>     <date>     <date>     <dbl>      <dbl>      <dbl>     <dbl>
#1  fundOPHI 2015-01-02 2017-01-20      1000  326.83685   1326.837  1.326837
#2  fundHIHI 2015-01-02 2017-01-20      1000    0.00000   1000.000  1.000000
#3  fundMNHI 2015-01-02 2017-01-20      1000  152.30210   1152.302  1.152302
#4  fundLOHI 2015-01-02 2017-01-20      1000  816.63808   1816.638  1.816638
#5  fundCLHI 2015-01-02 2017-01-20      1000  323.18564   1323.186  1.323186
#6  fundOPMN 2015-01-02 2017-01-20      1000  246.68001   1246.680  1.246680
#7  fundHIMN 2015-01-02 2017-01-20      1000  384.90915   1384.909  1.384909
#8  fundMNMN 2015-01-02 2017-01-20      1000    0.00000   1000.000  1.000000
#9  fundLOMN 2015-01-02 2017-01-20      1000  529.34170   1529.342  1.529342
#10 fundCLMN 2015-01-02 2017-01-20      1000  221.03926   1221.039  1.221039
#11 fundOPLO 2015-01-02 2017-01-20      1000  268.31155   1268.312  1.268312
#12 fundHILO 2015-01-02 2017-01-20      1000  649.35074   1649.351  1.649351
#13 fundMNLO 2015-01-02 2017-01-20      1000  298.28509   1298.285  1.298285
#14 fundLOLO 2015-01-02 2017-01-20      1000    0.00000   1000.000  1.000000
#15 fundCLLO 2015-01-02 2017-01-20      1000  208.85690   1208.857  1.208857
#16 fundOPCL 2015-01-02 2017-01-20      1000   30.55969   1030.560  1.030560
#17 fundHICL 2015-01-02 2017-01-20      1000  400.59057   1400.591  1.400591
#18 fundMNCL 2015-01-02 2017-01-20      1000  117.96808   1117.968  1.117968
#19 fundLOCL 2015-01-02 2017-01-20      1000  530.68975   1530.690  1.530690
#20 fundCLCL 2015-01-02 2017-01-20      1000    0.00000   1000.000  1.000000

## load fund files which is from chunk `r simStaking-woutLog`.
fundOPHI <- readRDS('./data/fundOPHI.rds')
fundHIHI <- readRDS('./data/fundHIHI.rds')
fundMNHI <- readRDS('./data/fundMNHI.rds')
fundLOHI <- readRDS('./data/fundLOHI.rds')
fundCLHI <- readRDS('./data/fundCLHI.rds')
fundOPMN <- readRDS('./data/fundOPMN.rds')
fundHIMN <- readRDS('./data/fundHIMN.rds')
fundMNMN <- readRDS('./data/fundMNMN.rds')
fundLOMN <- readRDS('./data/fundLOMN.rds')
fundCLMN <- readRDS('./data/fundCLMN.rds')
fundOPLO <- readRDS('./data/fundOPLO.rds')
fundHILO <- readRDS('./data/fundHILO.rds')
fundMNLO <- readRDS('./data/fundMNLO.rds')
fundLOLO <- readRDS('./data/fundLOLO.rds')
fundCLLO <- readRDS('./data/fundCLLO.rds')
fundOPCL <- readRDS('./data/fundOPCL.rds')
fundHICL <- readRDS('./data/fundHICL.rds')
fundMNCL <- readRDS('./data/fundMNCL.rds')
fundLOCL <- readRDS('./data/fundLOCL.rds')
fundCLCL <- readRDS('./data/fundCLCL.rds')

## Placed orders - Fund size without log
fundList <- list(fundOPHI = fundOPHI, fundHIHI = fundHIHI, fundMNHI = fundMNHI, fundLOHI = fundLOHI, fundCLHI = fundCLHI, 
                 fundOPMN = fundOPMN, fundHIMN = fundHIMN, fundMNMN = fundMNMN, fundLOMN = fundLOMN, fundCLMN = fundCLMN, 
                fundOPLO = fundOPLO, fundHILO = fundHILO, fundMNLO = fundMNLO, fundLOLO = fundLOLO, fundCLLO = fundCLLO, 
                fundOPCL = fundOPCL, fundHICL = fundHICL, fundMNCL = fundMNCL, fundLOCL = fundLOCL, fundCLCL = fundCLCL)
```

```{r simStaking-withLog, eval = FALSE, include = FALSE}
##============================ EVAL = FALSE ================================
## 
## Leveraged model 2
## 
## Placed orders - Fund size with log
fundOPHI <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = log(1000))
fundHIHI <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = log(1000))
fundMNHI <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = log(1000))
fundLOHI <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = log(1000))
fundCLHI <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = log(1000))

fundOPMN <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = log(1000))
fundHIMN <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = log(1000))
fundMNMN <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = log(1000))
fundLOMN <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = log(1000))
fundCLMN <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = log(1000))

fundOPLO <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = log(1000))
fundHILO <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = log(1000))
fundMNLO <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = log(1000))
fundLOLO <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = log(1000))
fundCLLO <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = log(1000))

fundOPCL <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = log(1000))
fundHICL <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = log(1000))
fundMNCL <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = log(1000))
fundLOCL <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = log(1000))
fundCLCL <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = log(1000))

## Placed orders - Fund size with log
#'@ fundList <- list(fundOPHI = fundOPHI, fundHIHI = fundHIHI, fundMNHI = fundMNHI, fundLOHI = fundLOHI, fundCLHI = fundCLHI, 
#'@                  fundOPMN = fundOPMN, fundHIMN = fundHIMN, fundMNMN = fundMNMN, fundLOMN = fundLOMN, fundCLMN = fundCLMN, 
#'@                  fundOPLO = fundOPLO, fundHILO = fundHILO, fundMNLO = fundMNLO, fundLOLO = fundLOLO, fundCLLO = fundCLLO, 
#'@                  fundOPCL = fundOPCL, fundHICL = fundHICL, fundMNCL = fundMNCL, fundLOCL = fundLOCL, fundCLCL = fundCLCL)
#'@ 
#'@ ldply(fundList, function(x) { x %>% mutate(StartDate = first(Date), LatestDate = last(Date), InitFund = first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df

## A tibble: 20 × 7
#        .id  StartDate LatestDate InitFund LatestFund    Profit        RR
#      <chr>     <date>     <date>    <dbl>      <dbl>     <dbl>     <dbl>
#1  fundOPHI 2015-01-02 2017-01-20 6.907755 201.699419 194.79166 29.198982
#2  fundHIHI 2015-01-02 2017-01-20 6.907755   6.907755   0.00000  1.000000
#3  fundMNHI 2015-01-02 2017-01-20 6.907755  75.593102  68.68535 10.943222
#4  fundLOHI 2015-01-02 2017-01-20 6.907755 592.614380 585.70662 85.789718
#5  fundCLHI 2015-01-02 2017-01-20 6.907755 199.023237 192.11548 28.811565
#6  fundOPMN 2015-01-02 2017-01-20 6.907755 145.334081 138.42633 21.039263
#7  fundHIMN 2015-01-02 2017-01-20 6.907755 245.812470 238.90472 35.585000
#8  fundMNMN 2015-01-02 2017-01-20 6.907755   6.907755   0.00000  1.000000
#9  fundLOMN 2015-01-02 2017-01-20 6.907755 359.728088 352.82033 52.075975
#10 fundCLMN 2015-01-02 2017-01-20 6.907755 127.528193 120.62044 18.461597
#11 fundOPLO 2015-01-02 2017-01-20 6.907755 159.124291 152.21654 23.035600
#12 fundHILO 2015-01-02 2017-01-20 6.907755 452.725480 445.81772 65.538726
#13 fundMNLO 2015-01-02 2017-01-20 6.907755 180.580704 173.67295 26.141734
#14 fundLOLO 2015-01-02 2017-01-20 6.907755   6.907755   0.00000  1.000000
#15 fundCLLO 2015-01-02 2017-01-20 6.907755 117.219609 110.31185 16.969276
#16 fundOPCL 2015-01-02 2017-01-20 6.907755  17.669553  10.76180  2.557930
#17 fundHICL 2015-01-02 2017-01-20 6.907755 256.110890 249.20313 37.075849
#18 fundMNCL 2015-01-02 2017-01-20 6.907755  57.745913  50.83816  8.359577
#19 fundLOCL 2015-01-02 2017-01-20 6.907755 357.560612 350.65286 51.762200
#20 fundCLCL 2015-01-02 2017-01-20 6.907755   6.907755   0.00000  1.000000
```

```{r simStaking-woutLogLeverage, eval = FALSE, include = FALSE}
##============================ EVAL = FALSE ================================
## 
## Leveraged model 3
## 
## Due to the log(.initialfundSize) generates extremely high return compare to normal figure, I added a new parameter ".fundLeverageLog" which convert the normal fund size value into log into calculation and finally convert back to normal fund size figure."

## Placed orders - Fund size without log but exp() Leveraged.
#'@ fundOPHI <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundHIHI <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundMNHI <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundLOHI <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundCLHI <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = 1000, .fundLeverageLog = TRUE)

#'@ fundOPMN <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundHIMN <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundMNMN <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundLOMN <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundCLMN <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = 1000, .fundLeverageLog = TRUE)

#'@ fundOPLO <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundHILO <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundMNLO <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundLOLO <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundCLLO <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = 1000, .fundLeverageLog = TRUE)

#'@ fundOPCL <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundHICL <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundMNCL <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundLOCL <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = 1000, .fundLeverageLog = TRUE)
#'@ fundCLCL <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = 1000, .fundLeverageLog = TRUE)

## A tibble: 20 × 7
#        .id  StartDate LatestDate InitFund   LatestFund       Profit           RR
#       <chr>     <date>     <date>    <dbl>        <dbl>        <dbl>        <dbl>
# 1  fundOPHI 2015-01-02 2017-01-20     1000 2.096972e+27 7.701648e+03 2.096972e+24
# 2  fundHIHI 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03
# 3  fundMNHI 2015-01-02 2017-01-20     1000 3.900327e+04 1.064366e+03 3.900327e+01
# 4  fundLOHI 2015-01-02 2017-01-20     1000 2.718282e+00 9.620574e+09 2.718282e-03
# 5  fundCLHI 2015-01-02 2017-01-20     1000 6.689430e+23 6.611671e+03 6.689430e+20
# 6  fundOPMN 2015-01-02 2017-01-20     1000 2.454335e+01 1.027528e+03 2.454335e-02
# 7  fundHIMN 2015-01-02 2017-01-20     1000 2.718282e+00 2.628152e+03 2.718282e-03
# 8  fundMNMN 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03
# 9  fundLOMN 2015-01-02 2017-01-20     1000 2.718282e+00 3.916608e+04 2.718282e-03
# 10 fundCLMN 2015-01-02 2017-01-20     1000 1.585667e+01 9.900735e+02 1.585667e-02
# 11 fundOPLO 2015-01-02 2017-01-20     1000 1.152381e+00 3.455387e+03 1.152381e-03
# 12 fundHILO 2015-01-02 2017-01-20     1000 2.718282e+00 1.541190e+06 2.718282e-03
# 13 fundMNLO 2015-01-02 2017-01-20     1000 1.040560e+00 3.434093e+03 1.040560e-03
# 14 fundLOLO 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03
# 15 fundCLLO 2015-01-02 2017-01-20     1000 1.152544e+00 2.646148e+03 1.152544e-03
# 16 fundOPCL 2015-01-02 2017-01-20     1000 2.919029e+00 5.465890e+02 2.919029e-03
# 17 fundHICL 2015-01-02 2017-01-20     1000 2.718282e+00 2.278748e+05 2.718282e-03
# 18 fundMNCL 2015-01-02 2017-01-20     1000 1.034658e+01 9.680842e+02 1.034658e-02
# 19 fundLOCL 2015-01-02 2017-01-20     1000 2.718282e+00 2.407137e+08 2.718282e-03
# 20 fundCLCL 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03

##============================ EVAL = FALSE ================================
## Profit and Loss of single model (write in list format).
#'@ cbind(
#'@   OP = df.op %>% dplyr::select(Return.Back, Return.Lay) %>% colSums %>% data.frame, 
#'@   HI = df.hi %>% dplyr::select(Return.Back, Return.Lay) %>% colSums %>% data.frame, 
#'@   MN = df.mn %>% dplyr::select(Return.Back, Return.Lay) %>% colSums %>% data.frame, 
#'@   LO = df.lo %>% dplyr::select(Return.Back, Return.Lay) %>% colSums %>% data.frame, 
#'@   CL = df.cl %>% dplyr::select(Return.Back, Return.Lay) %>% colSums %>% data.frame)

## Placed orders - Fund size with log
fundList <- list(fundOPHI = fundOPHI, fundHIHI = fundHIHI, fundMNHI = fundMNHI, fundLOHI = fundLOHI, fundCLHI = fundCLHI, 
                 fundOPMN = fundOPMN, fundHIMN = fundHIMN, fundMNMN = fundMNMN, fundLOMN = fundLOMN, fundCLMN = fundCLMN, 
                 fundOPLO = fundOPLO, fundHILO = fundHILO, fundMNLO = fundMNLO, fundLOLO = fundLOLO, fundCLLO = fundCLLO, 
                 fundOPCL = fundOPCL, fundHICL = fundHICL, fundMNCL = fundMNCL, fundLOCL = fundLOCL, fundCLCL = fundCLCL)

## Summary of ROI
ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
## A tibble: 20 × 7
#        .id  StartDate LatestDate InitFund   LatestFund       Profit           RR
#       <chr>     <date>     <date>    <dbl>        <dbl>        <dbl>        <dbl>
# 1  fundOPHI 2015-01-02 2017-01-20     1000 2.096972e+27 7.701648e+03 2.096972e+24
# 2  fundHIHI 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03
# 3  fundMNHI 2015-01-02 2017-01-20     1000 3.900327e+04 1.064366e+03 3.900327e+01
# 4  fundLOHI 2015-01-02 2017-01-20     1000 2.718282e+00 9.620574e+09 2.718282e-03
# 5  fundCLHI 2015-01-02 2017-01-20     1000 6.689430e+23 6.611671e+03 6.689430e+20
# 6  fundOPMN 2015-01-02 2017-01-20     1000 2.454335e+01 1.027528e+03 2.454335e-02
# 7  fundHIMN 2015-01-02 2017-01-20     1000 2.718282e+00 2.628152e+03 2.718282e-03
# 8  fundMNMN 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03
# 9  fundLOMN 2015-01-02 2017-01-20     1000 2.718282e+00 3.916608e+04 2.718282e-03
# 10 fundCLMN 2015-01-02 2017-01-20     1000 1.585667e+01 9.900735e+02 1.585667e-02
# 11 fundOPLO 2015-01-02 2017-01-20     1000 1.152381e+00 3.455387e+03 1.152381e-03
# 12 fundHILO 2015-01-02 2017-01-20     1000 2.718282e+00 1.541190e+06 2.718282e-03
# 13 fundMNLO 2015-01-02 2017-01-20     1000 1.040560e+00 3.434093e+03 1.040560e-03
# 14 fundLOLO 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03
# 15 fundCLLO 2015-01-02 2017-01-20     1000 1.152544e+00 2.646148e+03 1.152544e-03
# 16 fundOPCL 2015-01-02 2017-01-20     1000 2.919029e+00 5.465890e+02 2.919029e-03
# 17 fundHICL 2015-01-02 2017-01-20     1000 2.718282e+00 2.278748e+05 2.718282e-03
# 18 fundMNCL 2015-01-02 2017-01-20     1000 1.034658e+01 9.680842e+02 1.034658e-02
# 19 fundLOCL 2015-01-02 2017-01-20     1000 2.718282e+00 2.407137e+08 2.718282e-03
# 20 fundCLCL 2015-01-02 2017-01-20     1000 2.718282e+00 5.350000e+02 2.718282e-03

## Details of ROI
llply(fundList, function(x) x[c('BR', 'fB', 'fS', 'EUB', 'EUS', 'Edge', 'PF', 'FC', 'Buy', 'Sell', 'BuyS', 'SellS', 'Profit', 'Bal', 'RR')] %>% dplyr::filter(PF >0 | FC > 0))
```

```{r simStaking-withLogLeverage, eval = FALSE, include = FALSE}
##============================ EVAL = FALSE ================================
## 
## Leveraged model 4
## 
## Placed orders - Fund size with log and revert back exp() after calculation.
fundOPHI <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundHIHI <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundMNHI <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundLOHI <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundCLHI <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)

fundOPMN <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundHIMN <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundMNMN <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundLOMN <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundCLMN <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)

fundOPLO <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundHILO <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundMNLO <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundLOLO <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundCLLO <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)

fundOPCL <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundHICL <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundMNCL <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundLOCL <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)
fundCLCL <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = log(1000), 
                      .fundLeverageLog = TRUE)

## Placed orders - Fund size with log
#'@ fundList <- list(fundOPHI = fundOPHI, fundHIHI = fundHIHI, fundMNHI = fundMNHI, fundLOHI = fundLOHI, fundCLHI = fundCLHI, 
#'@                  fundOPMN = fundOPMN, fundHIMN = fundHIMN, fundMNMN = fundMNMN, fundLOMN = fundLOMN, fundCLMN = fundCLMN, 
#'@                  fundOPLO = fundOPLO, fundHILO = fundHILO, fundMNLO = fundMNLO, fundLOLO = fundLOLO, fundCLLO = fundCLLO, 
#'@                  fundOPCL = fundOPCL, fundHICL = fundHICL, fundMNCL = fundMNCL, fundLOCL = fundLOCL, fundCLCL = fundCLCL)
#'@ 
#'@ ldply(fundList, function(x) { x %>% mutate(StartDate = first(Date), LatestDate = last(Date), InitFund = first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
# ldply(fundList, function(x) { x %>% mutate(StartDate = first(Date), LatestDate = last(Date), InitFund = first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
# A tibble: 20 × 7
#         .id  StartDate LatestDate InitFund   LatestFund       Profit           RR
#       <chr>     <date>     <date>    <dbl>        <dbl>        <dbl>        <dbl>
# 1  fundOPHI 2015-01-02 2017-01-20 6.907755 7.010568e+24 6.130503e+03 1.014884e+24
# 2  fundHIHI 2015-01-02 2017-01-20 6.907755 2.718282e+00 5.350000e+02 3.935116e-01
# 3  fundMNHI 2015-01-02 2017-01-20 6.907755 2.711146e+00 5.344836e+02 3.924786e-01
# 4  fundLOHI 2015-01-02 2017-01-20 6.907755 2.718282e+00 6.039260e+09 3.935116e-01
# 5  fundCLHI 2015-01-02 2017-01-20 6.907755 5.090087e+21 5.261994e+03 7.368655e+20
# 6  fundOPMN 2015-01-02 2017-01-20 6.907755 2.198185e+01 9.372727e+02 3.182199e+00
# 7  fundHIMN 2015-01-02 2017-01-20 6.907755 2.718282e+00 2.362245e+03 3.935116e-01
# 8  fundMNMN 2015-01-02 2017-01-20 6.907755 2.718282e+00 5.350000e+02 3.935116e-01
# 9  fundLOMN 2015-01-02 2017-01-20 6.907755 2.718282e+00 3.257372e+04 3.935116e-01
# 10 fundCLMN 2015-01-02 2017-01-20 6.907755 1.441047e+01 9.002950e+02 2.086129e+00
# 11 fundOPLO 2015-01-02 2017-01-20 6.907755 1.161927e+00 2.719083e+03 1.682061e-01
# 12 fundHILO 2015-01-02 2017-01-20 6.907755 2.718282e+00 1.202578e+06 3.935116e-01
# 13 fundMNLO 2015-01-02 2017-01-20 6.907755 1.043987e+00 2.932865e+03 1.511326e-01
# 14 fundLOLO 2015-01-02 2017-01-20 6.907755 2.718282e+00 5.350000e+02 3.935116e-01
# 15 fundCLLO 2015-01-02 2017-01-20 6.907755 1.166220e+00 1.999664e+03 1.688276e-01
# 16 fundOPCL 2015-01-02 2017-01-20 6.907755 2.861825e+00 5.414756e+02 4.142917e-01
# 17 fundHICL 2015-01-02 2017-01-20 6.907755 2.718282e+00 1.639176e+05 3.935116e-01
# 18 fundMNCL 2015-01-02 2017-01-20 6.907755 7.550813e+00 7.034814e+02 1.093092e+00
# 19 fundLOCL 2015-01-02 2017-01-20 6.907755 2.718282e+00 1.359407e+08 3.935116e-01
# 20 fundCLCL 2015-01-02 2017-01-20 6.907755 2.718282e+00 5.350000e+02 3.935116e-01
```

  From above table summary we can know that `model 1 without any leverage` will be growth with a stable pace where LoHi and LoHi generates highest return rates. fundLOHI indicates investment **fund** buy at **LO**west price and sell at **HI**ghest price and vice verse.

```  
# 4  fundLOHI 2015-01-02 2017-01-20      1000  816.63808   1816.638  1.816638
#12  fundHILO 2015-01-02 2017-01-20      1000  649.35074   1649.351  1.649351
```

#### 2.1.5.2 Garch vs EWMA

```{r simStakingG-woutLog, eval = FALSE, include = FALSE}
##============================ EVAL = FALSE ================================
## 
## Garch Model 1 without leverage.
## 
## Placed orders - Fund size with log

#'@ mbase <- USDJPY

## settled with highest price.
fundGMOPHI <- simStakesGarch(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundGMOPHI, file = './data/fundGMOPHI.rds')

fundGMHIHI <- simStakesGarch(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundGMHIHI, file = './data/fundGMHIHI.rds')

fundGMMNHI <- simStakesGarch(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundGMMNHI, file = './data/fundGMMNHI.rds')

fundGMLOHI <- simStakesGarch(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundGMLOHI, file = './data/fundGMLOHI.rds')

fundGMCLHI <- simStakesGarch(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = 1000)
saveRDS(fundGMCLHI, file = './data/fundGMCLHI.rds')


## settled with mean price.
fundGMOPMN <- simStakesGarch(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundGMOPMN, file = './data/fundGMOPMN.rds')

fundGMHIMN <- simStakesGarch(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundGMHIMN, file = './data/fundGMHIMN.rds')

fundGMMNMN <- simStakesGarch(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundGMMNMN, file = './data/fundGMMNMN.rds')

fundGMLOMN <- simStakesGarch(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = 1000)
saveRDS(fundGMLOMN, file = './data/fundGMLOMN.rds')

fundGMCLMN <- simStakesGarch(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = 1000); saveRDS(fundGMCLMN, file = './data/fundGMCLMN.rds')


## settled with lowest price.
fundGMOPLO <- simStakesGarch(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundGMOPLO, file = './data/fundGMOPLO.rds')

fundGMHILO <- simStakesGarch(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundGMHILO, file = './data/fundGMHILO.rds')

fundGMMNLO <- simStakesGarch(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundGMMNLO, file = './data/fundGMMNLO.rds')

fundGMLOLO <- simStakesGarch(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundGMLOLO, file = './data/fundGMLOLO.rds')


## settled with closing price.
fundGMCLLO <- simStakesGarch(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = 1000)
saveRDS(fundGMCLLO, file = './data/fundGMCLLO.rds')

fundGMOPCL <- simStakesGarch(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundGMOPCL, file = './data/fundGMOPCL.rds')

fundGMHICL <- simStakesGarch(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundGMHICL, file = './data/fundGMHICL.rds')

fundGMMNCL <- simStakesGarch(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundGMMNCL, file = './data/fundGMMNCL.rds')

fundGMLOCL <- simStakesGarch(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundGMLOCL, file = './data/fundGMLOCL.rds')

fundGMCLCL <- simStakesGarch(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = 1000)
saveRDS(fundGMCLCL, file = './data/fundGMCLCL.rds')

## Placed orders - Fund size without log
fundGMList <- list(fundOPHI = fundGMOPHI, fundHIHI = fundGMHIHI, fundMNHI = fundGMMNHI, fundLOHI = fundGMLOHI, fundCLHI = fundGMCLHI, 
                fundOPMN = fundGMOPMN, fundHIMN = fundGMHIMN, fundGMMNMN = fundGMMNMN, fundLOMN = fundGMLOMN, fundCLMN = fundGMCLMN, 
                fundOPLO = fundGMOPLO, fundHILO = fundGMHILO, fundMNLO = fundGMMNLO, fundLOLO = fundGMLOLO, fundCLLO = fundGMCLLO, 
                fundOPCL = fundGMOPCL, fundHICL = fundGMHICL, fundMNCL = fundGMMNCL, fundLOCL = fundGMLOCL, fundCLCL = fundGMCLCL)

ldply(fundGMList, function(x) { x %>% mutate(StartDate = first(Date), LatestDate = last(Date), InitFund = first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
## # A tibble: 20 x 7
#          .id  StartDate LatestDate InitFund LatestFund       Profit       RR
#        <chr>     <date>     <date>    <dbl>      <dbl>        <dbl>    <dbl>
# 1   fundOPHI 2015-01-02 2017-01-20     1000   1344.257 3.442572e+02 1.344257
# 2   fundHIHI 2015-01-02 2017-01-20     1000   1000.006 5.815563e-03 1.000006
# 3   fundMNHI 2015-01-02 2017-01-20     1000   1185.847 1.858470e+02 1.185847
# 4   fundLOHI 2015-01-02 2017-01-20     1000   1770.291 7.702907e+02 1.770291
# 5   fundCLHI 2015-01-02 2017-01-20     1000   1362.749 3.627491e+02 1.362749
# 6   fundOPMN 2015-01-02 2017-01-20     1000   1266.433 2.664327e+02 1.266433
# 7   fundHIMN 2015-01-02 2017-01-20     1000   1392.315 3.923148e+02 1.392315
# 8 fundGMMNMN 2015-01-02 2017-01-20     1000   1000.000 3.088960e-06 1.000000
# 9   fundLOMN 2015-01-02 2017-01-20     1000   1443.834 4.438342e+02 1.443834
#10   fundCLMN 2015-01-02 2017-01-20     1000   1266.810 2.668104e+02 1.266810
#11   fundOPLO 2015-01-02 2017-01-20     1000   1298.491 2.984907e+02 1.298491
#12   fundHILO 2015-01-02 2017-01-20     1000   1713.915 7.139146e+02 1.713915
#13   fundMNLO 2015-01-02 2017-01-20     1000   1245.405 2.454050e+02 1.245405
#14   fundLOLO 2015-01-02 2017-01-20     1000   1000.000 0.000000e+00 1.000000
#15   fundCLLO 2015-01-02 2017-01-20     1000   1258.850 2.588497e+02 1.258850
#16   fundOPCL 2015-01-02 2017-01-20     1000   1031.448 3.144812e+01 1.031448
#17   fundHICL 2015-01-02 2017-01-20     1000   1453.842 4.538417e+02 1.453842
#18   fundMNCL 2015-01-02 2017-01-20     1000   1090.863 9.086251e+01 1.090863
#19   fundLOCL 2015-01-02 2017-01-20     1000   1507.365 5.073648e+02 1.507365
#20   fundCLCL 2015-01-02 2017-01-20     1000   1000.000 1.020225e-06 1.000000
```

  From above table summary we can know that `model 1 without any leverage` will be growth with a stable pace where LoHi and LoHi generates highest return rates. fundLOHI indicates investment **fund** buy at **LO**west price and sell at **HI**ghest price and vice verse.

```  
# 4  fundGMLOHI 2015-01-02 2017-01-20     1000   1770.291 7.702907e+02 1.770291
#12  fundGMHILO 2015-01-02 2017-01-20     1000   1713.915 7.139146e+02 1.713915
```

#### 2.1.5.3 MCMC vs Bayesian Time Series


#### 2.1.5.4 MIDAS


### 2.1.6 Return of Investment Optimization

#### 2.1.6.1 ARIMA vs ETS

  Now we apply the bootstrap (Application of Monte Carlo method to simulate 10000 times) onto the simulation of the forecasting.

```{r test-etsBoostrap, echo = FALSE, eval = FALSE}
##============================ EVAL = FALSE ================================
## Application of Monte Carlo method to simulate 10000 times.
## 
## bootstraping simulation.
fundOPHI <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Hi', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundHIHI <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Hi', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundMNHI <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Hi', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundLOHI <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Hi', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundCLHI <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Hi', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)

fundOPMN <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Mn', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundHIMN <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Mn', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundMNMN <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Mn', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundLOMN <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Mn', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundCLMN <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Mn', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)

fundOPLO <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Lo', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundHILO <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Lo', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundMNLO <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Lo', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundLOLO <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Lo', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundCLLO <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Lo', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)

fundOPCL <- simStakesETS(mbase, .prCat = 'Op', .setPrice = 'Cl', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundHICL <- simStakesETS(mbase, .prCat = 'Hi', .setPrice = 'Cl', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundMNCL <- simStakesETS(mbase, .prCat = 'Mn', .setPrice = 'Cl', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundLOCL <- simStakesETS(mbase, .prCat = 'Lo', .setPrice = 'Cl', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)
fundCLCL <- simStakesETS(mbase, .prCat = 'Cl', .setPrice = 'Cl', .initialFundSize = 1000, 
                      .simulate = TRUE, .bootstrap = TRUE)

## Placed orders - Fund size with log
fundList <- list(fundOPHI = fundOPHI, fundHIHI = fundHIHI, fundMNHI = fundMNHI, fundLOHI = fundLOHI, fundCLHI = fundCLHI, 
                 fundOPMN = fundOPMN, fundHIMN = fundHIMN, fundMNMN = fundMNMN, fundLOMN = fundLOMN, fundCLMN = fundCLMN, 
                 fundOPLO = fundOPLO, fundHILO = fundHILO, fundMNLO = fundMNLO, fundLOLO = fundLOLO, fundCLLO = fundCLLO, 
                 fundOPCL = fundOPCL, fundHICL = fundHICL, fundMNCL = fundMNCL, fundLOCL = fundLOCL, fundCLCL = fundCLCL)

ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
## A tibble: 20 x 7
#        .id  StartDate LatestDate InitFund LatestFund    Profit       RR
#      <chr>     <date>     <date>    <dbl>      <dbl>     <dbl>    <dbl>
# 1 fundOPHI 2015-01-02 2017-01-20     1000   1327.136 327.13568 1.327136
# 2 fundHIHI 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
# 3 fundMNHI 2015-01-02 2017-01-20     1000   1152.588 152.58775 1.152588
# 4 fundLOHI 2015-01-02 2017-01-20     1000   1815.757 815.75702 1.815757
# 5 fundCLHI 2015-01-02 2017-01-20     1000   1323.481 323.48132 1.323481
# 6 fundOPMN 2015-01-02 2017-01-20     1000   1249.002 249.00240 1.249002
# 7 fundHIMN 2015-01-02 2017-01-20     1000   1384.823 384.82307 1.384823
# 8 fundMNMN 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
# 9 fundLOMN 2015-01-02 2017-01-20     1000   1528.111 528.11075 1.528111
#10 fundCLMN 2015-01-02 2017-01-20     1000   1222.920 222.92029 1.222920
#11 fundOPLO 2015-01-02 2017-01-20     1000   1268.312 268.31154 1.268312
#12 fundHILO 2015-01-02 2017-01-20     1000   1648.839 648.83925 1.648839
#13 fundMNLO 2015-01-02 2017-01-20     1000   1304.609 304.60943 1.304609
#14 fundLOLO 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
#15 fundCLLO 2015-01-02 2017-01-20     1000   1208.857 208.85688 1.208857
#16 fundOPCL 2015-01-02 2017-01-20     1000   1030.560  30.55969 1.030560
#17 fundHICL 2015-01-02 2017-01-20     1000   1400.894 400.89448 1.400894
#18 fundMNCL 2015-01-02 2017-01-20     1000   1120.002 120.00224 1.120002
#19 fundLOCL 2015-01-02 2017-01-20     1000   1530.542 530.54241 1.530542
#20 fundCLCL 2015-01-02 2017-01-20     1000   1000.000   0.00000 1.000000
```

```{r multi-etsM}
## set all models provided by ets function.
ets.m1 <- c('A', 'M', 'Z')
ets.m2 <- c('N', 'A', 'M', 'Z')
ets.m3 <- c('N', 'A', 'M', 'Z')
ets.m <- do.call(paste0, expand.grid(ets.m1, ets.m2, ets.m3))
rm(ets.m1, ets.m2, ets.m3)

pp <- expand.grid(c('Op', 'Hi', 'Mn', 'Lo', 'Cl'), c('Op', 'Hi', 'Mn', 'Lo', 'Cl')) %>% mutate(PP = paste(Var1, Var2)) %>% .$PP %>% str_split(' ')
```

```{r multi-ets, echo = FALSE, eval = FALSE}
## Application of Monte Carlo method to simulate 10000 times.
## 
## pre-run and saved models.
##============================ EVAL = FALSE ================================
#Unit: seconds
#                                                 expr
#llply(ets.m[1:2], function(x) {     simStakesETS(mbase, .model = x, .prCat = pp[[1]][1], .setPrice = pp[[1]][2],          .initialFundSize = 1000) }, .progress = "text")
#     min       lq     mean   median       uq     max neval
# 46.7458 49.80663 51.08373 50.88039 52.53208 59.5116   100
 
#Unit: seconds
#                                                 expr
#llply(ets.m[1:2], function(x) {     simStakesETS(mbase, .model = x, .prCat = pp[[1]][1], .setPrice = pp[[1]][2],          .initialFundSize = 1000) }, .progress = "text")
#      min       lq     mean   median       uq      max neval
# 46.81515 47.33999 48.20982 47.98835 49.01683 51.46196   100

## .parallel and .progress parameters do not work.
## 
#'@ microbenchmark(res <- llply(ets.m, function(x) {
#'@     llply(pp, function(y) {
#'@         z = simStakesETS(mbase, .model = x, .prCat = y[1], .setPrice = y[2], .initialFundSize = 1000, .simulate = TRUE, .bootstrap = TRUE)
#'@         txt1 <- paste0('saveRDS(z', ', file = \'./data/', x, '.', y[1], y[2], '.rds\'); rm(z)')
#'@         eval(parse(text = txt1))
#'@         cat(paste0(txt1, ' done!', '\n'))
#'@     }, .parallel = TRUE)
#'@   cat(paste(x, 'done', '\n'))
#'@ }, .parallel = TRUE))
## 

microbenchmark(res <- llply(ets.m, function(x) {
    llply(pp, function(y) {
        z = simStakesETS(mbase, .model = x, .prCat = y[1], .setPrice = y[2], 
                      .initialFundSize = 1000, .simulate = TRUE, .bootstrap = TRUE)
        txt1 <- paste0('saveRDS(z', ', file = \'./data/', x, '.', y[1], y[2], '.rds\'); rm(z)')
        eval(parse(text = txt1))
        cat(paste0(txt1, ' done!', '\n'))
    })
    cat(paste(x, 'done', '\n'))
    }))

#'@ sapply(ets.m, function(x) { 
#'@     dir('data', pattern = x) %>% length
#'@    }, USE.NAMES = TRUE)
#ANN MNN ZNN AAN MAN ZAN AMN MMN ZMN AZN MZN ZZN ANA MNA ZNA AAA MAA ZAA AMA MMA ZMA AZA MZA ZZA ANM MNM ZNM AAM 
# 25  25  25  25  25  25   0  25  25  25  25  25   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
#MAM ZAM AMM MMM ZMM AZM MZM ZZM ANZ MNZ ZNZ AAZ MAZ ZAZ AMZ MMZ ZMZ AZZ MZZ ZZZ 
#  0   0   0   0   0   0   0   0  25  25  25  25  25  25   0  25  25  25  25  25

## http://r.789695.n4.nabble.com/Re-R-code-queries-td4674160.html
#'@ Error in ets(smp, model = .model) : Forbidden model combination
# ets7 <- ets(zz, model="AMN") 
# Error in ets(zz, model = "AMN") : Forbidden model combination 
```

  In order to trace the errors, here I check the source codes of the function but also test the coding as you can know via [<span style='color:blue'>Error : Forbidden model combination #554</span>](https://github.com/robjhyndman/forecast/issues/554). Here I only take 22 models among 48 models.

```{r valid.etsModels, echo = FALSE, eval = FALSE}
## filtered valid models.
##============================ EVAL = FALSE ================================
> ets.m
 [1] "ANN" "MNN" "ZNN" "AAN" "MAN" "ZAN" "AMN" "MMN" "ZMN" "AZN" "MZN" "ZZN" "ANA" "MNA" "ZNA" "AAA" "MAA" "ZAA"
[19] "AMA" "MMA" "ZMA" "AZA" "MZA" "ZZA" "ANM" "MNM" "ZNM" "AAM" "MAM" "ZAM" "AMM" "MMM" "ZMM" "AZM" "MZM" "ZZM"
[37] "ANZ" "MNZ" "ZNZ" "AAZ" "MAZ" "ZAZ" "AMZ" "MMZ" "ZMZ" "AZZ" "MZZ" "ZZZ"
> sapply(ets.m, function(x) { 
      dir('data', pattern = x) %>% length
   }, USE.NAMES = TRUE) %>% .[. > 0]
ANN MNN ZNN AAN MAN ZAN MMN ZMN AZN MZN ZZN ANZ MNZ ZNZ AAZ MAZ ZAZ MMZ ZMZ AZZ MZZ ZZZ 
 25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25 
> sapply(ets.m, function(x) { 
      dir('data', pattern = x) %>% length
   }, USE.NAMES = TRUE) %>% .[. > 0] %>% length
[1] 22]
```

```{r ROI-ETS, warning = FALSE}
## load the pre-run and saved models.
## Profit and Loss of multi-ets models. 22 models.

## Due to the file name contains 'MNM' is not found in directory but appear in dir(), Here I force to omit it...
#' @> sapply(ets.m, function(x) { 
#' @     dir('data', pattern = x) %>% length
#' @ }, USE.NAMES = TRUE) %>% .[. > 0]
#ANN MNN ZNN AAN MAN ZAN MMN ZMN AZN MZN ZZN MNM ANZ MNZ ZNZ AAZ MAZ ZAZ MMZ ZMZ AZZ MZZ ZZZ 
# 25  25  25  25  25  25  25  25  25  25  25   1  25  25  25  25  25  25  25  25  25  25  25

nms <- sapply(ets.m, function(x) { 
    dir('data', pattern = x) %>% length
  }, USE.NAMES = TRUE) %>% .[. == 25] %>% names #here I use only [. == 25].


#'@ nms <- sapply(ets.m, function(x) { 
#'@    dir('data', pattern = x) %>% length
#'@  }, USE.NAMES = TRUE) %>% .[. > 0] %>% names #here original [. > 0].

fls <- sapply(nms, function(x) {
    sapply(pp, function(y) { 
        dir('data', pattern = paste0(x, '.', y[1], y[2]))
    })
  })

## From 22 ets models with 25 hilo, opcl, mnmn, opop etc different price data. There will be 550 models.
fundList <- llply(fls, function(dt) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
          readRDS(file = paste0('./data/', dt))) %>% tbl_df
  })
names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))

## Summary of ROI
ets.tbl <- ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
```

```{r roi-ets, echo = FALSE, eval = FALSE}
## plot html table
##============================ EVAL = FALSE ================================
tagList(
  tags$div(align = "center", 
           class = "bg-info", 
           tags$h3(class = "bg-primary", "Profit and Loss of Investment (2015-Jan-02 2017-Jan-20)"), 
           tags$h5(align = "center", class = "text-muted", 
                   "Error-Trend-Seasonal or ExponenTial Smoothing Models")), 
  as.htmlwidget(ets.tbl %>% formattable(list(
    
    LatestFund = formatter('span', style = x ~ formattable::style(color = ifelse(rank(-x) <= 3, 'blue', 'grey')), x ~ paste0(round(x, 2), ' (rank: ', sprintf('%02f', rank(-x)), ')')), 
    
    Profit = formatter('span', style = x ~ formattable::style(color = ifelse(rank(-x) <= 3, 'blue', 'grey')), x ~ paste0(round(x, 2), ' (rank: ', sprintf('%02f', rank(-x)), ')')), 
    
    RR = formatter('span', style = x ~ formattable::style(color = ifelse(rank(-x) <= 3, 'blue', 'grey')), x ~ sprintf('%1.2f%% (rank: %.0f)', 100 * x, rank(-x)))))))
```

```{r plot-ets2, echo = FALSE}
## plot interactive table
ets.tbl %>% datatable(
    caption = "Table 2.1.7.1 : Summary of ROI (2015-Jan-01 to 2017-Jan-20)", 
    escape = FALSE, filter = 'top', rownames = FALSE, 
    extensions = list('ColReorder' = NULL, 'RowReorder' = NULL, 
                      'Buttons' = NULL, 'Responsive' = NULL), 
    options = list(dom = 'BRrltpi', autoWidth = TRUE,  scrollX = TRUE, 
                   lengthMenu = list(c(10, 50, 100, -1), c('10', '50', '100', 'All')), 
                   ColReorder = TRUE, rowReorder = TRUE, 
                   buttons = list('copy', 'print', 
                                  list(extend = 'collection', 
                                       buttons = c('csv', 'excel', 'pdf'), 
                                       text = 'Download'), I('colvis'))))
```

```{r concludes1, warning = FALSE}
#'@ ets.tbl %>% dplyr::filter(RR == max(RR))
# A tibble: 2 x 7
#       .id  StartDate LatestDate InitFund LatestFund  Profit       RR
#     <chr>     <date>     <date>    <dbl>      <dbl>   <dbl>    <dbl>
#1 AZN.LoHi 2015-01-02 2017-01-20     1000   1834.058 834.058 1.834058
#2 AZZ.LoHi 2015-01-02 2017-01-20     1000   1834.058 834.058 1.834058

ldply(c('LoHi', 'HiLo'), function(ppr) {
  ets.tbl %>% dplyr::filter(.id %in% grep(ppr, ets.tbl$.id, value = TRUE)) %>% dplyr::filter(RR == max(RR)) %>% unique
  })
# A tibble: 4 x 7
#       .id  StartDate LatestDate InitFund LatestFund   Profit       RR
#     <chr>     <date>     <date>    <dbl>      <dbl>    <dbl>    <dbl>
#1 AZN.LoHi 2015-01-02 2017-01-20     1000   1834.058 834.0580 1.834058
#2 AZZ.LoHi 2015-01-02 2017-01-20     1000   1834.058 834.0580 1.834058
#3 AZN.HiLo 2015-01-02 2017-01-20     1000   1666.752 666.7518 1.666752
#4 AZZ.HiLo 2015-01-02 2017-01-20     1000   1666.752 666.7518 1.666752
```

  From above table, we find the ets model `AZN` and `AZZ` generates highest return compare to rest of 21 ets models.

  *Figlewski (2004)* applied few models and also using different length of data for comparison. Now I use daily Hi-Lo and 365 days data in order to predict the next market price. Since I only predict 2 years investment therefore a further research works on the data sizing and longer prediction terms need (for example: 1 month, 3 months, 6 months data to predict coming price, 2ndly comparison of the ROI from 7 years or upper).

**Variance/Volatility Analsis**

  Hereby, I try to place bets on the variance which is requested by the assessment. Firstly we look at **Auto Arima** model.

```{r fundList-AutoArima}
## load the pre-run and saved models.
## Profit and Loss of Arima models.

fundList <- llply(flsAutoArima, function(dt) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
          readRDS(file = paste0('./data/', dt))) %>% tbl_df
  })
names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))
```

```{r varStaking-AutoArima}
## Focast the variance and convert to probability.
varHL <- fundList[grep('HILO|LOHI', names(fundList))]
ntm <- c(names((varHL)[names(varHL) %in% c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')]), names((varHL)[!names(varHL) %in% c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')])) %>% str_replace('.HILO|.LOHI', '') %>% unique %>% sort

varHL1 <- suppressMessages(llply(varHL, function(dtx) {
  mm = tbl_df(dtx) %>% dplyr::select(Date, USDJPY.High, USDJPY.Low, USDJPY.Close, Point.Forecast)
  names(mm)[5] = as.character(dtx$Model[1])
  names(mm) = str_replace_all(names(mm), 'HiLo', 'High')
  names(mm) = str_replace_all(names(mm), 'LoHi', 'Low')
  mm
  }) %>% join_all) %>% tbl_df

varHL2 <- suppressMessages(llply(ntm, function(nm) {
    mld = varHL1[grep(nm, names(varHL1))]
    mld[,3] = abs(mld[,1] - mld[,2])
    names(mld)[3] = paste0(nm, '.Rng')
    mld = mld[colSums(!is.na(mld)) > 0]
    data.frame(varHL1[c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')], USDJPY.Rng = abs(varHL1$USDJPY.High - varHL1$USDJPY.Low), mld) %>% tbl_df
    }) %>% unique %>% join_all %>% tbl_df)
```

```{r varStaking-2AutoArima, results = 'asis'}
## Application of MASS::mvrnorm() or mvtnorm::rmvnorm() ##nope
#'@ varHL2 <- xts(varHL2[, -1], as.Date(varHL2$Date))

## Betting strategy 1 - Normal range betting
varB1 <- varHL2[,c('Date', names(varHL2)[str_detect(names(varHL2), '.Rng')])]

varB1 <- suppressMessages(llply(ntm, function(nm) {
    dtx = bind_cols(varB1[c('USDJPY.Rng')], varB1[grep(nm, names(varB1))]) %>% mutate_if(is.numeric, funs(ifelse(USDJPY.Rng >= ., ., -100)))
    dtx2 = dtx[, 2] %>% mutate_if(is.numeric, funs(ifelse(. >= 0, 100, -100)))
    dtx3 = dtx2 %>% mutate_if(is.numeric, funs(cumsum(.) + 1000))
    dtx4 = dtx2 %>% mutate_if(is.numeric, funs(lag(1000 + cumsum(.))))
    dtx4[1,1] = 1000
    dtx5 = bind_cols(varB1['Date'], dtx4, dtx2, dtx3)
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng2', 'Bal')
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng1', 'PL')
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng', 'BR')
    dtx5
}) %>% join_all %>% tbl_df)

## shows the last 6 balance (ROI)
tail(data.frame(varB1['Date'], varB1[grep('Bal', names(varB1))])) %>% kable(width = 'auto')
```

```{r plot-varAutoArima, echo = FALSE, results = 'asis'}
## Betting strategy 1 - Normal range betting
## Plot the ROI of investment fund.
plotAutoArima <- data.frame(varB1['Date'], varB1[grep('Bal', names(varB1))])
LineAutoArima <-  gvisLineChart(plotAutoArima, 'Date', names(plotAutoArima)[-1],
                        options = list(title = 'Auto Arima Models', 
                                       gvis.editor = 'Edit me!'))
plot(LineAutoArima)
```

  Now we look at **ETS** model.

```{r fundList-ETS}
## 
## From 22 ets models with 25 hilo, opcl, mnmn, opop etc different price data. There will be 550 models.
fundList <- llply(fls[grep('HiLo|LoHi', fls)], function(dt) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
          readRDS(file = paste0('./data/', dt))) %>% tbl_df
  })
names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))
```

```{r varStaking-ETS}
## Focast the variance and convert to probability.
varHL <- fundList[grep('HiLo|LoHi', names(fundList))]
ntm <- c(names((varHL)[names(varHL) %in% c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')]), names((varHL)[!names(varHL) %in% c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')])) %>% str_replace('.HiLo|.LoHi', '') %>% unique %>% sort

varHL1 <- suppressMessages(llply(varHL, function(dtx) {
  mm = tbl_df(dtx) %>% dplyr::select(Date, USDJPY.High, USDJPY.Low, USDJPY.Close, Point.Forecast)
  names(mm)[5] = as.character(dtx$Model[1])
  names(mm) = str_replace_all(names(mm), 'HiLo', 'High')
  names(mm) = str_replace_all(names(mm), 'LoHi', 'Low')
  mm
  }) %>% join_all) %>% tbl_df

varHL2 <- suppressMessages(llply(ntm, function(nm) {
    mld = varHL1[grep(nm, names(varHL1))]
    mld[,3] = abs(mld[,1] - mld[,2])
    names(mld)[3] = paste0(nm, '.Rng')
    mld = mld[colSums(!is.na(mld)) > 0]
    data.frame(varHL1[c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')], USDJPY.Rng = abs(varHL1$USDJPY.High - varHL1$USDJPY.Low), mld) %>% tbl_df
    }) %>% unique %>% join_all %>% tbl_df)
```

```{r varStaking-2ETS, results = 'asis'}
## Application of MASS::mvrnorm() or mvtnorm::rmvnorm() ##nope
#'@ varHL2 <- xts(varHL2[, -1], as.Date(varHL2$Date))

## Betting strategy 1 - Normal range betting
varB1 <- varHL2[,c('Date', names(varHL2)[str_detect(names(varHL2), '.Rng')])]

varB1 <- suppressMessages(llply(ntm, function(nm) {
    dtx = bind_cols(varB1[c('USDJPY.Rng')], varB1[grep(nm, names(varB1))]) %>% mutate_if(is.numeric, funs(ifelse(USDJPY.Rng >= ., ., -100)))
    dtx2 = dtx[, 2] %>% mutate_if(is.numeric, funs(ifelse(. >= 0, 100, -100)))
    dtx3 = dtx2 %>% mutate_if(is.numeric, funs(cumsum(.) + 1000))
    dtx4 = dtx2 %>% mutate_if(is.numeric, funs(lag(1000 + cumsum(.))))
    dtx4[1,1] = 1000
    dtx5 = bind_cols(varB1['Date'], dtx4, dtx2, dtx3)
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng2', 'Bal')
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng1', 'PL')
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng', 'BR')
    dtx5
}) %>% join_all %>% tbl_df)

## shows the last 6 balance (ROI)
tail(data.frame(varB1['Date'], varB1[grep('Bal', names(varB1))])) %>% kable(width = 'auto')
```

  From above coding and below graph, we can know my *first staking method*^[The variance range is solely based on forecasted figures irrespect the volatility of real time effect, only made settlement after closed market. After that use the daily Hi-Lo variance compare to initial forecasted variance. Even though there has no such highest price nor lowest price will not affect the predicted transaction.] which is **NOT EXCEED** the daily Hi-Lo range will generates profit or ruined depends on the statistical models.

```{r plot-varETS, echo = FALSE, results = 'asis'}
## Betting strategy 1 - Normal range betting
## Plot the ROI of investment fund.
plotETS <- data.frame(varB1['Date'], varB1[grep('Bal', names(varB1))])
LineETS <-  gvisLineChart(plotETS, 'Date', names(plotETS)[-1],
                        options = list(title = 'ETS Models', 
                                       gvis.editor = 'Edit me!'))
plot(LineETS)
```

  <s>The 2nd staking method is based on real-time volativity which is the transaction will only stand if the highest or lowest price happenned within hte variance, same with the initial Kelly staking model. The closing Price will be Highest or Lowest price if one among the price doesn't exist within the range of variance.</s>

<span style='color:red'>*It doesn't work since the closed price* **MUST** *be between highest and lowest price. Here I stop it and set as `eval = FALSE` for display purpose but not execute*</span>

```{r varStaking-2, echo = FALSE, eval = FALSE}
## ================== eval = FALSE =============================
## Do not execute...
## 
## Betting strategy 2 - Real range betting
suppressMessages(llply(ntm, function(nm) {
    dtx = varHL2[grep(nm, names(varHL2))]
    dtx1 = dtx[,3]
    tts = varHL2[c('USDJPY.Low', 'USDJPY.High', 'USDJPY.Rng', 'USDJPY.Close')]
    dtxL = dtx[,1] %>% mutate_if(is.numeric, funs(ifelse(. >= tts$USDJPY.Low, ., tts$USDJPY.Close)))
    dtxH = dtx[,2] %>% mutate_if(is.numeric, funs(ifelse(. <= tts$USDJPY.High, ., tts$USDJPY.Close)))
    dtxHL = bind_cols(dtxH, dtxL)
    dtx1 = dtxHL[,1] - dtxHL[,2]
    dtx1 %<>% mutate_if(is.numeric, funs(ifelse(tts$USDJPY.Rng >= ., 100, -100))) %>% tbl_df
    names(dtx1) = 'PL'
    data.frame(BR = rep(1000, nrow(dtx)), dtx1) %>% tbl_df %>% mutate(Bal = BR + PL)
}))
[[1]]
# A tibble: 535 x 3
#      BR    PL   Bal
#   <dbl> <dbl> <dbl>
# 1  1000   100  1100
# 2  1000   100  1100
# 3  1000   100  1100
# 4  1000   100  1100
# 5  1000   100  1100
# 6  1000   100  1100
# 7  1000   100  1100
# 8  1000   100  1100
# 9  1000   100  1100
#10  1000   100  1100
# ... with 525 more rows

[[2]]
# A tibble: 535 x 3
#      BR    PL   Bal
#   <dbl> <dbl> <dbl>
# 1  1000   100  1100
# 2  1000   100  1100
# 3  1000   100  1100
# 4  1000   100  1100
# 5  1000   100  1100
# 6  1000   100  1100
# 7  1000   100  1100
```


```{r varStaking-3, echo = FALSE, eval = FALSE}
## ================== eval = FALSE =============================
## Do not execute...
## 
## Betting strategy 2 - Kelly Criterion (default)
##   kindly refer to simStakesETS(...)

```

#### 2.1.6.2 Garch vs EWMA

  As I mentioned in first section which is the combination models will be more than 10,000, therefore I try to refer to `acf()` and `pacf()` to determine the best fit value `p` and `q` for ARMA model. You can refer to below articles for more information.
  
  - [<span style='color:blue'>时间序列ARMA中p，q选择</span>](http://blog.csdn.net/xiaodongxiexie/article/details/54633272?locationNum=2&fps=1)
  - [<span style='color:blue'>时间序列分析之ARIMA模型预测__R篇</span>](http://www.cnblogs.com/bicoffee/p/3838049.html)^[Due to this article compare the combination models with `acf` and `pacf` and eventually get that `acf` and `pacf` produce a better fit model.]
  - [<span style='color:blue'>Time Series Analysis of Apple Stock Prices Using GARCH models</span>](https://rstudio-pubs-static.s3.amazonaws.com/258811_b43d4c7bb2c74851b5b95f29a09c5b30.html)
  - [<span style='color:blue'>时间序列建模问题，如何准确的建立时间序列模型？</span>](https://www.zhihu.com/question/31833683/answer/116155144)
  - [<span style='color:blue'>Arima预测模型（R语言）</span>](http://blog.csdn.net/desilting/article/details/39013825)
  - [<span style='color:blue'>时间序列分析---(ARIMA模型)](http://zhoulili1987619126.lofter.com/post/1cc8f7a3_74e7f10)
  - [<span style='color:blue'>Identifying the numbers of AR or MA terms in an ARIMA model</span>](http://people.duke.edu/~rnau/411arim3.htm)
  - [<span style='color:blue'>8.7 ARIMA modelling in R</span>](https://www.otexts.org/fpp/8/7)^[(a) The best model (with smallest AICc) is selected from the following four:] ^[ARIMA(2,d,2),] ^[ARIMA(0,d,0),] ^[ARIMA(1,d,0),] ^[ARIMA(0,d,1).]
  - [<span style='color:blue'>2.2 Partial Autocorrelation Function (PACF)</span>](https://onlinecourses.science.psu.edu/stat510/node/62)
  - [<span style='color:blue'>Forecasting Time Series</span>](http://ptrckprry.com/course/forecasting/lecture/archfit.html)
  - [<span style='color:blue'>Lecture 4: Modelling Volatility of S&P returns</span>](https://klein.uk/teaching/quant2/docs/Lec4.html)
  - [<span style='color:blue'>Course Files :: MPO1 & MPO1A</span>](https://github.com/mfrmn/qrm/blob/master/MPO1A/L2E2Ascript.r)
  - [<span style='color:blue'>第二章平稳时间序列模型——ACF和PACF和样本ACF/PACF</span>](http://www.cnblogs.com/xuanlvshu/p/5410721.html)

```{r multi-garchM, message = FALSE, warning = FALSE}
## Multiple Garch models inside `rugarch` package.
.variance.model.par <- c('sGARCH', 'fGARCH', 'eGARCH', 'gjrGARCH', 'apARCH', 'iGARCH', 'csGARCH', 'realGARCH')

## http://blog.csdn.net/desilting/article/details/39013825
## 接下来需要选择合适的ARIMA模型，即确定ARIMA(p,d,q)中合适的 p、q 值，我们通过R中的“acf()”和“pacf”函数来做判断。
#'@ .garchOrder.par <- expand.grid(0:2, 0:2, KEEP.OUT.ATTRS = FALSE) %>% mutate(PP = paste(Var1, Var2))
#'@ .garchOrder.par %<>% .$PP %>% str_split(' ') %>% llply(as.numeric)

.solver.par <- c('hybrid', 'solnp', 'nlminb', 'gosolnp', 'nloptr', 'lbfgs')

.sub.fGarch.par <- c('GARCH', 'TGARCH', 'AVGARCH', 'NGARCH', 'NAGARCH', 'APARCH', 'GJRGARCH', 'ALLGARCH')

.dist.model.par <- c('norm', 'snorm', 'std', 'sstd', 'ged', 'sged', 'nig', 'ghyp', 'jsu')

pp <- expand.grid(c('Op', 'Hi', 'Mn', 'Lo', 'Cl'), c('Op', 'Hi', 'Mn', 'Lo', 'Cl')) %>% mutate(PP = paste(Var1, Var2)) %>% .$PP %>% str_split(' ')
pp <- llply(pp, function(x) x[x[1]!=x[2]][!is.null(x)])
pp <- pp[!is.na(pp)]
```

```{r acf-pacf, echo = FALSE}
pq.op <- diff(as.vector(Op(mbase)), difference = 1)
pq.hi <- diff(as.vector(Hi(mbase)), difference = 1)
pq.mn <- diff(as.vector((Hi(mbase) + Lo(mbase)) / 2), difference = 1)
pq.lo <- diff(as.vector(Lo(mbase)), difference = 1)
pq.cl <- diff(as.vector(Cl(mbase)), difference = 1)

## determine the p value in Arima, Garch models.
autoplot(pacf(pq.op, lag.max = 100, main = 'PACF of Opening Price'))
autoplot(pacf(pq.hi, lag.max = 100, main = 'PACF of Highest Price'))
autoplot(pacf(pq.mn, lag.max = 100, main = 'PACF of Mean Price'))
autoplot(pacf(pq.lo, lag.max = 100, main = 'PACF of Lowest Price'))
autoplot(pacf(pq.cl, lag.max = 100, main = 'PACF of Closing Price'))

## determine the q value in Arima, Garch models.
autoplot(acf(pq.op, lag.max = 100, main = 'ACF of Opening Price'))
autoplot(acf(pq.hi, lag.max = 100, main = 'ACF of Highest Price'))
autoplot(acf(pq.mn, lag.max = 100, main = 'ACF of Mean Price'))
autoplot(acf(pq.lo, lag.max = 100, main = 'ACF of Lowest Price'))
autoplot(acf(pq.cl, lag.max = 100, main = 'ACF of Closing Price'))
```

  Here I use a function to find the optimal value of `p` and `q` from `armaOrder(0,0)` to `armaOrder(5,5)` by refer to [<span style='color:blue'>R-ARMA(p,q)如何选找最小AIC的p,q值</span>](http://blog.csdn.net/u012543538/article/details/38663715).
  
  However, due to optimal `r` and `s` for Garch model will consume alot of time to test the optimal `garchOrder(r,s)` here I skip it and just using default `garchOrder(1,1)`.
  
  - An ARMA(p,q) model specifies the conditional mean of the process
  - The GARCH(r,s) model specifies the conditional variance of the process

  Kindly refer to [<span style='color:blue'>What is the difference between GARCH and ARMA?</span>](https://stats.stackexchange.com/questions/41509/what-is-the-difference-between-garch-and-arma) for more information.

```{r pq-value, warning = FALSE}
pq.op <- suppressWarnings(armaSearch(Op(mbase)))
pq.hi <- suppressWarnings(armaSearch(Hi(mbase)))
USDJPY.Mean = (Hi(mbase) + Lo(mbase)) / 2
names(USDJPY.Mean) <- 'USDJPY.Mean'
pq.mn <- suppressWarnings(armaSearch(USDJPY.Mean))
pq.lo <- suppressWarnings(armaSearch(Lo(mbase)))
pq.cl <- suppressWarnings(armaSearch(Cl(mbase)))

## From below comparison, we know that the 'CSS-ML' is better than 'ML'.
## 
#'@ > suppressWarnings(armaSearch(Cl(mbase)))
# the min AIC = 1635.718 , p = 2 , q = 4 
# p q      AIC
# 1  0 0 1641.616
# 2  0 1 1643.616
# 3  0 2 1645.062
# 4  0 3 1647.036
# 5  0 4 1645.792
# 6  0 5 1639.704
# 7  1 0 1643.616
# 8  1 1 1645.616
# 9  1 2 1640.169
# 10 1 3 1640.896
# 11 1 4 1636.914
# 12 1 5 1636.216
# 13 2 0 1644.991
# 14 2 1 1640.297
# 15 2 2 1642.826
# 16 2 3 1644.150
# 17 2 4 1635.718
# 18 2 5 1637.614
# 19 3 0 1646.901
# 20 3 1 1641.620
# 21 3 2 1643.541
# 22 3 3 1646.957
# 23 3 4 1636.964
# 24 3 5 1639.715
# 25 4 0 1645.485
# 26 4 1 1639.150
# 27 4 2 1635.929
# 28 4 3 1636.975
# 29 4 4 1638.584
# 30 4 5 1640.505
# 31 5 0 1640.214
# 32 5 1 1638.289
# 33 5 2 1637.855
# 34 5 3 1639.926
# 35 5 4 1638.875
# 36 5 5 1641.102
#'@ > suppressWarnings(armaSearch(Cl(mbase), .method = 'CSS-ML'))
# the min AIC = 1634.782 , p = 3 , q = 3 
# p q      AIC
# 1  0 0 1641.616
# 2  0 1 1643.616
# 3  0 2 1645.062
# 4  0 3 1647.036
# 5  0 4 1645.792
# 6  0 5 1639.704
# 7  1 0 1643.616
# 8  1 1 1645.616
# 9  1 2 1640.168
# 10 1 3 1640.896
# 11 1 4 1636.914
# 12 1 5 1636.216
# 13 2 0 1644.991
# 14 2 1 1640.297
# 15 2 2 1642.734
# 16 2 3 1643.207
# 17 2 4 1635.717
# 18 2 5 1636.222
# 19 3 0 1646.901
# 20 3 1 1641.620
# 21 3 2 1644.290
# 22 3 3 1634.782
# 23 3 4 1636.240
# 24 3 5 1638.113
# 25 4 0 1645.485
# 26 4 1 1639.150
# 27 4 2 1635.929
# 28 4 3 1636.975
# 29 4 4 1638.584
# 30 4 5 1640.505
# 31 5 0 1640.214
# 32 5 1 1638.289
# 33 5 2 1637.855
# 34 5 3 1639.926
# 35 5 4 1636.145
# 36 5 5 1641.102

#'@ > suppressWarnings(armaSearch(Mn(USDJPY.Mean)))
# the min AIC = 1369.503 , p = 3 , q = 2 
#    p q      AIC
# 1  0 0 1408.854
# 2  0 1 1379.128
# 3  0 2 1380.864
# 4  0 3 1382.213
# 5  0 4 1383.223
# 6  0 5 1377.906
# 7  1 0 1378.869
# 8  1 1 1380.755
# 9  1 2 1382.479
# 10 1 3 1384.072
# 11 1 4 1379.514
# 12 1 5 1378.089
# 13 2 0 1380.792
# 14 2 1 1382.634
# 15 2 2 1384.310
# 16 2 3 1384.559
# 17 2 4 1375.647
# 18 2 5 1377.609
# 19 3 0 1381.965
# 20 3 1 1383.946
# 21 3 2 1369.503
# 22 3 3 1376.475
# 23 3 4 1377.613
# 24 3 5 1379.641
# 25 4 0 1383.859
# 26 4 1 1385.411
# 27 4 2 1375.856
# 28 4 3 1373.091
# 29 4 4 1378.873
# 30 4 5 1380.859
# 31 5 0 1382.015
# 32 5 1 1379.627
# 33 5 2 1377.687
# 34 5 3 1379.462
# 35 5 4 1380.859
# 36 5 5 1382.397
# 
#'@ > suppressWarnings(armaSearch(Mn(USDJPY.Mean), .method = 'CSS-ML'))
#  Show Traceback
#  
#  Rerun with Debug
#  Error in arima(data, order = c(p, 1, q), method = .method) : 
#   non-stationary AR part from CSS
# 
#'@ > suppressWarnings(armaSearch(Mn(USDJPY.Mean), .method = 'CSS'))
# the min AIC =  , p =  , q =  
#    p q AIC
# 1  0 0  NA
# 2  0 1  NA
# 3  0 2  NA
# 4  0 3  NA
# 5  0 4  NA
# 6  0 5  NA
# 7  1 0  NA
# 8  1 1  NA
# 9  1 2  NA
# 10 1 3  NA
# 11 1 4  NA
# 12 1 5  NA
# 13 2 0  NA
# 14 2 1  NA
# 15 2 2  NA
# 16 2 3  NA
# 17 2 4  NA
# 18 2 5  NA
# 19 3 0  NA
# 20 3 1  NA
# 21 3 2  NA
# 22 3 3  NA
# 23 3 4  NA
# 24 3 5  NA
# 25 4 0  NA
# 26 4 1  NA
# 27 4 2  NA
# 28 4 3  NA
# 29 4 4  NA
# 30 4 5  NA
# 31 5 0  NA
# 32 5 1  NA
# 33 5 2  NA
# 34 5 3  NA
# 35 5 4  NA
# 36 5 5  NA


#'@ > pq.op <- suppressWarnings(armaSearch(Op(mbase)))
# the min AIC = 1623.453 , p = 4 , q = 4 
#'@ > pq.hi <- suppressWarnings(armaSearch(Hi(mbase)))
# the min AIC = 1490.073 , p = 4 , q = 3 
#'@ > USDJPY.Mean = (Hi(mbase) + Lo(mbase)) / 2
#'@ > names(USDJPY.Mean) <- 'USDJPY.Mean'
#'@ > pq.mn <- suppressWarnings(armaSearch(USDJPY.Mean))
# the min AIC = 1369.503 , p = 3 , q = 2 
#'@ > pq.lo <- suppressWarnings(armaSearch(Lo(mbase)))
# the min AIC = 1711.913 , p = 3 , q = 2 
#'@ > pq.cl <- suppressWarnings(armaSearch(Cl(mbase)))
# the min AIC = 1634.782 , p = 3 , q = 3
```

  Paper [<span style='color:blue'>Multivariate DCC-GARCH Model
-With Various Error Distributions</span>](https://github.com/englianhu/binary.com-interview-question/blob/8eefcd3a1615918d032eca2ccc560f7548215c99/reference/Multivariate%20DCC-GARCH%20Model.pdf) applied few error distribuions onto dcc-garch model (I leave the multivariate Garch for future works):-

  - multivariate
Gaussian
  - Student's t
  - skew Student's t

  Below are the conclusion from the paper.

  *In this thesis we have studied the DCC-GARCH model with Gaussian, Student’s t and skew Student’s t-distributed errors. For a basic understanding of the GARCH model, the univariate GARCH and multivariate GARCH models in general were discussed before the DCC-GARCH model was considered...*
  
  *After precenting the theory, DCC-GARCH models were fit to a portfolio consisting of European, American and Japanese stocks assuming three different error distributions; multivariate Gaussian, Student’s t and skew Student’s t. The European, American and Japanese series seemed to have a bit different marginal distributions.* **The DCC-GARCH model with skew Student’s t-distributed errors performed best.** *But even the DCC-GARCH with skew Student’s t-distributed errors did explain all of the asymmetry in the asset series. Hence even better models may be considered. Comparing the DCC-GARCH model with the CCC-GARCH model using the Kupiec test showed that the first model gave a better fit to the data.*
  
  *There are several possible directions for future work. It might be better to use other marginal models such as the EGARCH, QGARCH and GJR GARCH, that capture the asymmetry in the conditional variances. If the univariate GARCH models are more correct, the DCC-GARCH model might yield better results. Other error distributions, such as a Normal Inverse Gaussian (NIG) might also give a better fit. When we fitted the Gaussian, Student’s t- and skew Student’s t-distibutions to the data, we assumed all the distributions to be the same for the three series. This might be a too restrictive criteria. A model where the marginal distributions is allowed to be different for each of the asset series might give a better fit. One then might use a Copula to link the marginals together.*

```{r dstSS, eval = FALSE, include = FALSE}
dstGarch <- llply(.dist.model.par, function(dst) {
  simStakesGarch(mbase, .solver = 'hybrid', .prCat = 'Mn', .prCat.method = 'CSS-ML', 
                 .baseDate = ymd('2015-01-01'), .parallel = FALSE, 
                 .progress = 'none', .setPrice = 'Cl', .setPrice.method = 'CSS-ML', 
                 .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                 .filterBets = FALSE, .variance.model = 
                   list(model = 'sGARCH', garchOrder = c(1, 1), 
                        submodel = NULL, external.regressors = NULL, 
                        variance.targeting = FALSE), 
                 .mean.model = list(armaOrder = c(1, 1), 
                                    include.mean = TRUE, archm = FALSE, 
                                    archpow = 1, arfima = FALSE, 
                                    external.regressors = NULL, 
                                    archex = FALSE), .dist.model = dst, 
                 start.pars = list(), fixed.pars = list())})
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
#the min AIC = 1369.503 , p = 3 , q = 2 
#the min AIC = 1634.782 , p = 3 , q = 3 
names(dstGarch) <- .dist.model.par
saveRDS(dstGarch, './data/dstsGarch.Mn.Cl.rds')

## Overwrite above function with LoHi.
#'@ dstGarch <- llply(.dist.model.par, function(dst) {
#'@   simStakesGarch(mbase, .solver = 'hybrid', .prCat = 'Lo', .prCat.method = 'CSS-ML', 
#'@                  .baseDate = ymd('2015-01-01'), .parallel = FALSE, 
#'@                  .progress = 'none', .setPrice = 'Hi', .setPrice.method = 'CSS-ML', 
#'@                  .initialFundSize = 1000, .fundLeverageLog = FALSE, 
#'@                  .filterBets = FALSE, .variance.model = 
#'@                    list(model = 'fGARCH', garchOrder = c(1, 1), 
#'@                         submodel = 'GJRGARCH', external.regressors = NULL, 
#'@                         variance.targeting = FALSE), 
#'@                  .mean.model = list(armaOrder = c(1, 1), 
#'@                                     include.mean = TRUE, archm = FALSE, 
#'@                                     archpow = 1, arfima = FALSE, 
#'@                                     external.regressors = NULL, 
#'@                                     archex = FALSE), .dist.model = dst, 
#'@                  start.pars = list(), fixed.pars = list())})
#'@ names(dstGarch) <- .dist.model.par
#'@ saveRDS(dstGarch, './data/dstGJRGARCH.Lo.Hi.rds')
#method = 'CSS-ML', the min AIC = 1710.3744852797, p = 2, q = 2
#method = 'CSS-ML', the min AIC = 1490.07263872323, p = 4, q = 3
#Error in diag(fit$robust.cvar) : invalid 'nrow' value (too large or NA)
```

```{r read-dst}
dstGarch <- readRDS('./data/dstsGarch.Mn.Cl.rds')
dst.m <- ldply(dstGarch, function(x) x %>% dplyr::select(BR, Profit, Bal, RR) %>% tail(1)) %>% mutate(BR = 1000, Profit = Bal - BR, RR = Bal / BR)
#    .id   BR   Profit      Bal       RR
#1  norm 1000 182.7446 1182.745 1.182745
#2 snorm 1000 202.8955 1202.895 1.202895
#3   std 1000 155.7099 1155.710 1.155710
#4  sstd 1000 143.0274 1143.027 1.143027
#5   ged 1000 135.8819 1135.882 1.135882
#6  sged 1000 143.1829 1143.183 1.143183
#7   nig 1000 163.9009 1163.901 1.163901
#8  ghyp 1000 137.0740 1137.074 1.137074
#9   jsu 1000 178.7324 1178.732 1.178732

dst.m %>% kable(width = 'auto')
```

  From above comparison of distribution used, we know that ``r dst.m %>% dplyr::filter(RR == max(RR)) %>% .$.id`` distribution generates most return (notes : I should use LoHi instead of MnCl since it will generates highest ROI, however most of LoHi Garch models facing large data size or large NA values error. Here I skip the LoHi data for comparison). Now we know the best `p` and `q`, solver using `hybrid`, and best fitted distribution. Now we try to compare the Garch models.

```{r garch-M, eval = FALSE, include = FALSE}
### 1) sGARCH =================================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[1], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[1], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.1 fGARCH - GARCH =========================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'GARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.GARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.2 fGARCH - TGARCH ========================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'TGARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.TGARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.3 fGARCH - AVGARCH =======================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'AVGARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.AVGARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.4 fGARCH - NGARCH ========================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'NGARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.NGARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.5 fGARCH - NAGARCH ======================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'NAGARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.NAGARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.6 fGARCH - APARCH =======================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'APARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.APARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.7 fGARCH - GJRGARCH =====================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'GJRGARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.GJRGARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 2.8 fGARCH - ALLGARCH =====================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[2], garchOrder = c(1, 1), 
                     submodel = 'ALLGARCH', external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[2], '.ALLGARCH.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 3 eGARCH ==================================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[3], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[3], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 4 gjrGARCH =================================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[4], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[4], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 5 apARCH ==================================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[5], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[5], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 6 iGARCH =================================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[6], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[6], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 7 csGARCH ================================================================
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[7], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[7], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)

### 8 realGARCH ===============================================================
## http://www.unstarched.net/2014/01/02/the-realized-garch-model/
## Omitted due to error.
z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', .realizedVol = 'Ad', 
                   .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[8], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())

txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[8], '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
eval(parse(text = txt1))
cat(paste0(txt1, ' done!', '\n'))
rm(z)
```

```{r multi-garch, eval = FALSE, include = FALSE}
## ---------- eval = FALSE -------------------
## http://www.unstarched.net/2014/01/02/the-realized-garch-model/
## https://eranraviv.com/volatility-forecast-evaluation-in-r/
## https://eranraviv.com/univariate-volatility-forecast-evaluation/

garch.m <- suppressAll(llply(.variance.model.par[-2], function(vm) {
  z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = pp[[19]][1], 
                     .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                     .parallel = FALSE, .progress = 'text', 
                     .setPrice = pp[[19]][2], .setPrice.method = 'CSS-ML', 
                     .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                     .filterBets = FALSE, .variance.model = list(
                       model = vm, garchOrder = c(1, 1), submodel = NULL, 
                       external.regressors = NULL, variance.targeting = FALSE), 
                     .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                        archm = FALSE, archpow = 1, arfima = FALSE, 
                                        external.regressors = NULL, archex = FALSE), 
                     .dist.model = .dist.model.par[2], start.pars = list(), 
                     fixed.pars = list())
  
  txt1 <- paste0('saveRDS(z', ', file = \'./data/', vm, '.', pp[[19]][1], '.', pp[[19]][2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
  eval(parse(text = txt1))
  cat(paste0(txt1, ' done!', '\n'))
  rm(z)
  }, .progress = 'text'))
```

```{r multi-garch2, eval = FALSE, include = FALSE}
## load the pre-run and saved models.
## Profit and Loss of Arima models.

flsGarchM <- dir('./data', pattern = '.Mn.Cl.snorm.hybrid')

fundList <- llply(flsGarchM, function(dt) {
  fl = paste0('./data/', dt)
  if(file.size(fl) > 100) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
        readRDS(file = fl)) %>% tbl_df
  }})

#'@ names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))
names(fundList) <- flsGarchM %>% str_replace_all('.Mn.Cl.snorm.hybrid.rds', '')
fundList[sapply(fundList, is.null)] <- NULL

## Summary of ROI
gm.tbl <- ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
## The rest omitted due to error.
# A tibble: 16 x 7
#                          .id  StartDate LatestDate InitFund LatestFund   Profit       RR
#                        <chr>     <date>     <date>    <dbl>      <dbl>    <dbl>  #  <dbl>
# 1                     apARCH 2015-01-02 2017-01-20     1000        NaN      NaN      NaN
# 2                    csGARCH 2015-01-02 2017-01-20     1000        NaN      NaN      NaN
# 3                     eGARCH 1970-01-02 1971-06-20     1000   1182.745 182.7446 1.182745
# 4              fGARCH.APARCH 2015-01-02 2017-01-20     1000        NaN      NaN      NaN
# 5               fGARCH.GARCH 2015-01-02 2017-01-20     1000   1177.530 177.5298 1.177530
# 6   fGARCH.GJRGARCH.EWMA.est 2015-01-02 2017-01-20     1000   1203.857 203.8566 1.203857
# 7 fGARCH.GJRGARCH.EWMA.fixed 2015-01-02 2017-01-20     1000   1204.554 204.5540 1.204554
# 8            fGARCH.GJRGARCH 2015-01-02 2017-01-20     1000   1204.554 204.5538 1.204554
# 9          gjrGARCH.EWMA.est 2015-01-02 2017-01-20     1000   1190.555 190.5551 1.190555
#10        gjrGARCH.EWMA.fixed 2015-01-02 2017-01-20     1000   1189.793 189.7935 1.189793
#11                   gjrGARCH 2015-01-02 2017-01-20     1000   1189.793 189.7935 1.189793
#12            iGARCH.EWMA.est 2015-01-02 2017-01-20     1000   1191.571 191.5711 1.191571
#13          iGARCH.EWMA.fixed 2015-01-02 2017-01-20     1000   1191.571 191.5711 1.191571
#14                     iGARCH 2015-01-02 2017-01-20     1000   1191.571 191.5711 1.191571
#15                  realGARCH 2015-01-02 2017-01-20     1000        NaN      NaN      NaN
#16                     sGARCH 2015-01-02 2017-01-20     1000   1196.402 196.4022 1.196402

gm.tbl %>% kable(width = 'auto')
```

```{r gjrGarch, eval = FALSE, include = FALSE}
## Wrongly... 'fGARCH.GJRGARCH' model is the best but not 'gjrGARCH' model.
## 
### 4 gjrGARCH ===========================================================
## Now I try to build ohlc price for best mode - gjrGarch.

gjrGarch <- llply(pp, function(y) {
  z = simStakesGarch(mbase, .solver = .solver.par[1], .prCat = y[1], 
                   .prCat.method = 'CSS-ML', .baseDate = ymd('2015-01-01'), 
                   .parallel = FALSE, .progress = 'text', 
                   .setPrice = y[2], .setPrice.method = 'CSS-ML', 
                   .initialFundSize = 1000, .fundLeverageLog = FALSE, 
                   .filterBets = FALSE, .variance.model = list(
                     model = .variance.model.par[4], garchOrder = c(1, 1), 
                     submodel = NULL, external.regressors = NULL, 
                     variance.targeting = FALSE), 
                   .mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
                                      archm = FALSE, archpow = 1, arfima = FALSE, 
                                      external.regressors = NULL, archex = FALSE), 
                   .dist.model = .dist.model.par[2], start.pars = list(), 
                   fixed.pars = list())
  
  txt1 <- paste0('saveRDS(z', ', file = \'./data/', .variance.model.par[4], '.', y[1], '.', y[2], '.', .dist.model.par[2], '.', .solver.par[1], '.rds\')')
  eval(parse(text = txt1))
  cat(paste0(txt1, ' done!', '\n'))
  rm(z)
 })
```

  For dcc-Garch models which are multivariate Garch models will be future works : 
  
  - [<span style='color:blue'>Multivariate GARCH(1,1) in R</span>](https://stackoverflow.com/questions/35035857/multivariate-garch1-1-in-r)
  - [<span style='color:blue'>Multivariate volatility forecasting (1)</span>](https://eranraviv.com/multivariate-volatility-forecasting-1/)
  - [<span style='color:blue'>Multivariate volatility forecasting, part 2 – equicorrelation</span>](https://eranraviv.com/multivariate-volatility-forecasting-2/)
  - [<span style='color:blue'>The GARCH-DCC Model and 2-stage DCC(MVT) estimation</span>](http://www.unstarched.net/2013/01/03/the-garch-dcc-model-and-2-stage-dccmvt-estimation/)

  Below is the summary of ROI of Garch and EWMA by Kelly models.

```{r Garch-EWMA, echo = FALSE}
## norm distribution generates highest ROI compare to snorm.
flsEWMA <- dir('./data', pattern = '.hybrid')

fundList <- llply(flsEWMA, function(dt) {
  fl = paste0('./data/', dt)
  if(file.size(fl) > 100) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
        readRDS(file = fl)) %>% tbl_df
  }})

#'@ names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))
names(fundList) <- flsEWMA %>% str_replace_all('.rds', '')
fundList[sapply(fundList, is.null)] <- NULL

## Summary of ROI
gm.tbl <- ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df

tagList(
  tags$div(align = "center", 
           class = "bg-info", 
           tags$h3(class = "bg-primary", "Profit and Loss of Investment"), 
           tags$h5(align = "center", class = "text-muted", 
                   "Annual Stakes and Profit and Loss of Firm A at Agency A (2011-2015) ($0,000)")), 
  as.htmlwidget(gm.tbl %>% formattable(list(
    
    .id = color_tile('white', 'darkgoldenrod'), 
    
    LatestFund = formatter('span', style = x ~ formattable::style(color = ifelse(rank(-x) <= 3, 'green', 'gray')), x ~ paste0(round(x, 2), ' (rank: ', sprintf('%02d', rank(-x)), ')')), 
    
    Profit = color_tile('white', '#9B870C'), 
    
    RR = formatter('span', style = x ~ formattable::style(
	      color = ifelse(rank(-x) <= 3, 'green', 'gray')), x ~ sprintf('%1.2f%% (rank: %02d)', 100 * x, rank(-x)))))))
```

**Volatility Staking**

```{r ROI-Garch, echo = FALSE}
## load the pre-run and saved models.
## Profit and Loss of Arima models.

flsGarchM <- dir('./data', pattern = 'Hi.Lo+.snorm.hybrid|Lo.Hi+.snorm.hybrid')

fundList <- llply(flsGarchM, function(dt) {
  fl = paste0('./data/', dt)
  if(file.size(fl) > 100) {
    cbind(Model = str_replace_all(dt, '.rds', ''), 
        readRDS(file = fl)) %>% tbl_df
  }})

#'@ names(fundList) <- sapply(fundList, function(x) xts::first(x$Model))
names(fundList) <- flsGarchM %>% str_replace_all('.snorm.hybrid.rds', '')
fundList[sapply(fundList, is.null)] <- NULL

## Summary of ROI
#'@ gm.tbl <- ldply(fundList, function(x) { x %>% mutate(StartDate = xts::first(Date), LatestDate = last(Date), InitFund = xts::first(BR), LatestFund = last(Bal), Profit = sum(Profit), RR = LatestFund/InitFund) %>% dplyr::select(StartDate, LatestDate, InitFund, LatestFund, Profit, RR) %>% unique }) %>% tbl_df
```

```{r varStaking-varGarch, echo = FALSE}
## Focast the variance and convert to probability.
varHL <- fundList[grep('Hi.Lo|Lo.Hi', names(fundList))]
ntm <- c(names((varHL)[names(varHL) %in% c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')]), names((varHL)[!names(varHL) %in% c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')])) %>% str_replace('.Hi.Lo|.Lo.Hi', '') %>% unique %>% sort

varHL1 <- suppressMessages(llply(varHL, function(dtx) {
  mm = tbl_df(dtx) %>% dplyr::select(Date, USDJPY.High, USDJPY.Low, USDJPY.Close, Point.Forecast)
  names(mm)[5] = as.character(dtx$Model[1])
  names(mm) = str_replace_all(names(mm), 'Hi.Lo.snorm.hybrid', 'High')
  names(mm) = str_replace_all(names(mm), 'Lo.Hi.snorm.hybrid', 'Low')
  mm
  }) %>% join_all) %>% tbl_df

varHL2 <- suppressMessages(llply(ntm, function(nm) {
    mld = varHL1[grep(paste0('^', nm, '+', '.High|^', nm, '+', '.Low'), names(varHL1))]
    mld[,3] = abs(mld[,1] - mld[,2])
    names(mld)[3] = paste0(nm, '.Rng')
    mld = mld[colSums(!is.na(mld)) > 0]
    data.frame(varHL1[c('Date', 'USDJPY.High', 'USDJPY.Low', 'USDJPY.Close')], USDJPY.Rng = abs(varHL1$USDJPY.High - varHL1$USDJPY.Low), mld) %>% tbl_df
    }) %>% unique %>% join_all %>% tbl_df)
```

```{r varStaking-2varGarch, echo = FALSE, results = 'asis'}
## Application of MASS::mvrnorm() or mvtnorm::rmvnorm() ##nope
#'@ varHL2 <- xts(varHL2[, -1], as.Date(varHL2$Date))

## Betting strategy 1 - Normal range betting
varB1 <- varHL2[,c('Date', names(varHL2)[str_detect(names(varHL2), '.Rng')])]

varB1 <- suppressMessages(llply(ntm, function(nm) {
    dtx = bind_cols(varB1[c('USDJPY.Rng')], varB1[grep(nm, names(varB1))]) %>% mutate_if(is.numeric, funs(ifelse(USDJPY.Rng >= ., ., -100)))
    dtx2 = dtx[, 2] %>% mutate_if(is.numeric, funs(ifelse(. >= 0, 100, -100)))
    dtx3 = dtx2 %>% mutate_if(is.numeric, funs(cumsum(.) + 1000))
    dtx4 = dtx2 %>% mutate_if(is.numeric, funs(lag(1000 + cumsum(.))))
    dtx4[1,1] = 1000
    dtx5 = bind_cols(varB1['Date'], dtx4, dtx2, dtx3)
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng2', 'Bal')
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng1', 'PL')
    names(dtx5) = names(dtx5) %>% str_replace_all('Rng', 'BR')
    dtx5
}) %>% join_all %>% tbl_df)

## shows the last 6 balance (ROI)
tail(data.frame(varB1['Date'], varB1[grep('Bal', names(varB1))])) %>% kable(width = 'auto')
```

```{r plot-varGarch, echo = FALSE, results = 'asis'}
## Betting strategy 1 - Normal range betting
## Plot the ROI of investment fund.
plotGarch <- data.frame(varB1['Date'], varB1[grep('Bal', names(varB1))])
LineGarch <-  gvisLineChart(plotGarch, 'Date', names(plotGarch)[-1],
                        options = list(title = 'Garch Models', 
                                       gvis.editor = 'Edit me!'))
plot(LineGarch)
```

#### 2.1.6.3 MCMC vs Bayesian Time Series


#### 2.1.6.4 MIDAS


### 2.1.7 Conclusion


## 2.2 Question 2


## 2.3 Question 3


# 3. Conclusion



```{r stopPar, echo = FALSE}
## Set options back to original options
options(op)
options(warn = 0)
stopCluster(cl)
```

# 4. Appendix

## 4.1 Documenting File Creation 

  It's useful to record some information about how your file was created.

  - File creation date: 2015-07-22
  - File latest updated date: `r Sys.Date()`
  - `r R.version.string`
  - R version (short form): `r getRversion()`
  - [<span style='color:blue'>**rmarkdown** package</span>](https://github.com/rstudio/rmarkdown) version: `r packageVersion('rmarkdown')`
  - [<span style='color:blue'>**tufte** package</span>](https://github.com/rstudio/tufte) version: `r packageVersion('tufte')`
  - File version: 1.0.1
  - Author Profile: [<span style='color:blue'>®γσ, Eng Lian Hu</span>](https://beta.rstudioconnect.com/englianhu/ryo-eng/)
  - GitHub: [<span style='color:blue'>Source Code</span>](https://github.com/englianhu/binary.com-interview-question)
  - Additional session information
  
```{r info, echo = FALSE, warning = FALSE, results = 'asis'}
suppressMessages(require('dplyr', quietly = TRUE))
suppressMessages(require('formattable', quietly = TRUE))

lubridate::now()
sys1 <- devtools::session_info()$platform %>% unlist %>% data.frame(Category = names(.), session_info = .)
rownames(sys1) <- NULL
sys1 %>% formattable %>% as.htmlwidget

data.frame(Sys.info()) %>% mutate(Category = rownames(.)) %>% .[2:1] %>% rename(Category = Category, Sys.info =  Sys.info..) %>% formattable %>% as.htmlwidget

rm(sys1)
```

## 4.2 Reference

  01. [<span style='color:blue'>Stock Market Forecasting Using LASSO Linear Regression Model</span>](https://github.com/englianhu/binary.com-interview-question/blob/master/reference/Stock%20Market%20Forecasting%20Using%20LASSO%20Linear%20Regression%20Model.pdf)<img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  02. [<span style='color:blue'>Using LASSO from lars (or glmnet) package in R for variable selection</span>](http://stats.stackexchange.com/questions/58531/using-lasso-from-lars-or-glmnet-package-in-r-for-variable-selection?answertab=votes#tab-top)
  03. [<span style='color:blue'>Difference between glmnet() and cv.glmnet() in R?</span>](https://stackoverflow.com/questions/29311323/difference-between-glmnet-and-cv-glmnet-in-r?answertab=votes#tab-top)
  04. [<span style='color:blue'>Testing Kelly Criterion and Optimal f in R</span>](https://alphaism.wordpress.com/2012/04/13/testing-kelly-criterion-and-optimal-f-in-r) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  05. [<span style='color:blue'>Portfolio Optimization and Monte Carlo Simulation</span>](https://github.com/scibrokes/kelly-criterion/blob/master/references/Portfolio%20Optimization%20and%20Monte%20Carlo%20Simulation.pdf) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  06. [<span style='color:blue'>Glmnet Vignette</span>](https://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html)
  07. [<span style='color:blue'>lasso怎么用算法实现？</span>](http://cos.name/cn/topic/101533/#post-418215)
  08. [<span style='color:blue'>The Sparse Matrix and {glmnet}</span>](http://amunategui.github.io/sparse-matrix-glmnet/)
  09. [<span style='color:blue'>Regularization and Variable Selection via the Elastic Net</span>](https://github.com/englianhu/binary.com-interview-question/blob/master/reference/Regularization%20and%20Variable%20Selection%20via%20the%20Elastic%20Net.pdf)
  10. [<span style='color:blue'>LASSO, Ridge, and Elastic Net</span>](http://www4.stat.ncsu.edu/~post/josh/LASSO_Ridge_Elastic_Net_-_Examples.html) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  11. [<span style='color:blue'>热门数据挖掘模型应用入门（一）: LASSO回归</span>](http://cos.name/2016/10/data-mining-1-lasso/)
  12. [<span style='color:blue'>The Lasso Page</span>](http://statweb.stanford.edu/~tibs/lasso.html)
  13. [<span style='color:blue'>Call_Valuation.R</span>](https://api.rpubs.com/Mariano/call)
  14. [<span style='color:blue'>Lecture 6 – Stochastic Processes and Monte Carlo</span>](http://zorro-trader.com/manual/en/Lecture%206.htm)
  15. [<span style='color:blue'>The `caret` Package</span>](http://topepo.github.io/caret/index.html) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  16. [<span style='color:blue'>Time Series Cross Validation</span>](https://rpubs.com/crossxwill/time-series-cv) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  17. [<span style='color:blue'>Character-Code.com</span>](http://character-code.com/)
  18. [<span style='color:blue'>Size Matters – Kelly Optimization</span>](https://alphaism.wordpress.com/2012/03/26/size-matters-kelly-optimization/) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  19. [<span style='color:blue'>**Forecasting Volatility** *- (2004)by Stephen Figlewski*</span>](https://raw.githubusercontent.com/englianhu/binary.com-interview-question/fcad2844d7f10c486f3601af9932f49973548e4b/reference/Focasting%20Volatility.pdf)
  20. [<span style='color:blue'>**Successful Algorithmic Trading** *by Michael Halls Moore (2015)*</span>](https://raw.githubusercontent.com/englianhu/binary.com-interview-question/fcad2844d7f10c486f3601af9932f49973548e4b/reference/Successful%20Algorithmic%20Trading.pdf)
  21. [<span style='color:blue'>Financial Risk Modelling and Portfolio Optimization with R (2nd Edt)</span>](https://github.com/englianhu/binary.com-interview-question/blob/eec3bbe99c61b4e2e2f4a2b1c47e7a2fca6106c4/reference/Financial%20Risk%20Modelling%20and%20Portfolio%20Optimization%20with%20R%20(2nd%20Edt).pdf) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>
  22. [<span style='color:blue'>Analyzing Financial Data and Implementing Financial Models using R</span>](https://github.com/englianhu/binary.com-interview-question/blob/eec3bbe99c61b4e2e2f4a2b1c47e7a2fca6106c4/reference/Analyzing%20Financial%20Data%20and%20Implementing%20Financial%20Models%20using%20R.pdf) <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/hot.jpg?raw=true' width='20'>

**Powered by - Copyright® Intellectual Property Rights of <img src='https://raw.githubusercontent.com/englianhu/binary.com-interview-question/master/www/oda-army2.jpg?raw=true' width='24'> [<span style='color:blue'>Scibrokes®</span>](http://www.scibrokes.com)個人の経営企業**
